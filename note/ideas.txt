Consider doing a stack-based language in the intro section. That will give
readers some practice thinking in terms of stacks, which will then come in
handy when we get to the bytecode VM at the end.

See: https://leanpub.com/readevalprintlove003/read

Talk about how being concatenative helps compiling. To compile an expression,
we just concatenate compiling the subexpressions.

--

When talking about whether or not strings and numbers can have properties added,
consider what that would mean for equality on them.

--

When talking about early and late binding, use an example like this:

if (false) {
  var a = 1;
  var a = 2; // error here?
}

--

Define "parameter" and "argument" early on.

--

When talking about comparison operators, talk about how allowing comparison on
non-numeric types can be handy for polymorphic sorted collections.

--

Talk about what the stack frame would look like if we allowed variables to be
declared in the middle of an expression.

--

Question: Smalltalk implementations doesn't have to check that the number of
arguments to a method matches the number of parameters it expects. Why not?

--

Regarding error handling: a language should either give you enough features to
let you prevent an error, or to handle it. For example, in Vox, there's no way
to check the type of an object, but also you get a runtime error that you can't
catch if you pass an object of the wrong type to an operator. That's bad.

--

Consider interleaving a couple of "essays" that talk about more subjective
aspects of language design:

- The "novelty budget" and choosing which things to keep familiar and which to
  keep new.

- Learnability versus consistency. Being internally consistent leads to a
  simpler, more elegant language, but doesn't leverage what the user already
  knows.

- Building an entire ecosystem: implementation, spec, core libraries, docs, etc.

--

We don't have toString(), nor does "+" allow mixing string arguments with other
types. That's pretty limiting.
