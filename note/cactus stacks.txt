Thinking about using a heap-allocated cactus stack of call frames to keep things
simpler than Lua-style upvalues...

At the point that we're compiling a call, the function (or method) is on top of
the stack. We have not compiled the arguments yet, but we know a call is
occurring.

What do we need to do:

- Create the call frame for the function being called.
- Compile the arguments. Store each one in appropriate slots in the call frame.
- Begin executing the frame.

Ideally, we avoid uneeded copies. For example, we could compile all of the
arguments and store them in slots in the caller's frame, then create the new
frame and copy them, but that would be lame.

One tricky part is that if we create the call frame first and make it current,
then we need to compile the argument list as if we are in that call frame.
References to locals in the caller's space become like closure accesses.

In other words, compiling the arguments becomes part of the callee's prologue
(sort of) and not the caller's precall sequence.

Actually, that doesn't make sense. We can't make the called function current
without making it's *bytecode* current too. And, obviously, we can't put the
arg list code in the called function's bytecode. It may be called from multiple
places with different argument lists!

Given that, maybe the simplest thing to do is copy afterwards.