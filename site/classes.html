<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<title>Classes &middot; Crafting Interpreters</title>

<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="stylesheet" type="text/css" href="style.css" />

<!-- Oh, God, Source Code Pro is so beautiful it makes me want to cry. -->
<link href='http://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600' rel='stylesheet' type='text/css'>
<link rel="icon" type="image/png" href="image/favicon.png" />
<script src="jquery-1.10.1.min.js"></script>
<script src="script.js"></script>

<!-- Google analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42804721-2', 'auto');
  ga('send', 'pageview');
</script>

</head>
<body id="top">

<!-- <div class="scrim"></div> -->
<nav class="wide">
  <a href="/"><img src="image/logotype-small.png" title="Crafting Interpreters"></a>
  <div class="contents">
<!-- If there is a part, it must be a chapter within a part. -->
<h3><a href="#top">Classes<small>12</small></a></h3>

<ul>
    <li><a href="#class-declarations"><small>12.1</small> Class Declarations</a></li>
    <li><a href="#creating-instances"><small>12.2</small> Creating Instances</a></li>
    <li><a href="#properties-on-instances"><small>12.3</small> Properties on Instances</a></li>
    <li><a href="#methods-on-classes"><small>12.4</small> Methods on Classes</a></li>
    <li><a href="#this"><small>12.5</small> This</a></li>
    <li><a href="#constructors-and-initializers"><small>12.6</small> Constructors and Initializers</a></li>
    <li class="divider"></li>
    <li class="end-part"><a href="#challenges">Challenges</a></li>
    <li class="end-part"><a href="#design-note"><small>note</small>Prototypes and Power
</a></li>
</ul>


<div class="prev-next">
    <a href="resolving-and-binding.html" title="Resolving and Binding" class="left">&larr;&nbsp;Previous</a>
    <a href="a-tree-walk-interpreter.html" title="A Tree-Walk Interpreter">&uarr;&nbsp;Up</a>
    <a href="inheritance.html" title="Inheritance" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
</nav>

<nav class="narrow">
<a href="/"><img src="image/logotype-small.png" title="Crafting Interpreters"></a>
<a href="resolving-and-binding.html" title="Resolving and Binding" class="prev">←</a>
<a href="inheritance.html" title="Inheritance" class="next">→</a>
</nav>

<div class="page">
<div class="nav-wrapper">
<nav class="floating">
  <a href="/"><img src="image/logotype-small.png" title="Crafting Interpreters"></a>
  <div class="expandable">
<!-- If there is a part, it must be a chapter within a part. -->
<h3><a href="#top">Classes<small>12</small></a></h3>

<ul>
    <li><a href="#class-declarations"><small>12.1</small> Class Declarations</a></li>
    <li><a href="#creating-instances"><small>12.2</small> Creating Instances</a></li>
    <li><a href="#properties-on-instances"><small>12.3</small> Properties on Instances</a></li>
    <li><a href="#methods-on-classes"><small>12.4</small> Methods on Classes</a></li>
    <li><a href="#this"><small>12.5</small> This</a></li>
    <li><a href="#constructors-and-initializers"><small>12.6</small> Constructors and Initializers</a></li>
    <li class="divider"></li>
    <li class="end-part"><a href="#challenges">Challenges</a></li>
    <li class="end-part"><a href="#design-note"><small>note</small>Prototypes and Power
</a></li>
</ul>


<div class="prev-next">
    <a href="resolving-and-binding.html" title="Resolving and Binding" class="left">&larr;&nbsp;Previous</a>
    <a href="a-tree-walk-interpreter.html" title="A Tree-Walk Interpreter">&uarr;&nbsp;Up</a>
    <a href="inheritance.html" title="Inheritance" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
  <a id="expand-nav">≡</a>
</nav>
</div>

<article class="chapter">

  <div class="number">12</div>
  <h1>Classes</h1>

<div class="sign-up closable">
    <h1>This book is a work in progress!</h1>
    <span class="dismiss">&times;</span>
    <p>If you see a mistake, find something unclear, or have a suggestion, please <a href="https://github.com/munificent/craftinginterpreters/issues" target="_blank">let me know</a>. To learn when new chapters are up, join the mailing list:</p>

  <!-- Begin MailChimp Signup Form -->
  <div id="mc_embed_signup">
  <form action="//gameprogrammingpatterns.us7.list-manage.com/subscribe/post?u=0952ca43ed2536d6717766b88&amp;id=6e96334109" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate>
    <input type="email" value="" name="EMAIL" class="email" id="mce-EMAIL" placeholder="Your email address" required>
    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->
    <div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_0952ca43ed2536d6717766b88_6e96334109" tabindex="-1" value=""></div>
    <input type="submit" value="Sign me up!" name="subscribe" id="mc-embedded-subscribe" class="button">
  </form>
  </div>
  <!--End mc_embed_signup-->
  <p class="small">(I post about once a month. Don&#8217;t worry, I won&#8217;t spam you.)</p>
</div>

<p>We&rsquo;re eleven chapters in, and the interpreter sitting on your machine is nearly
a full-fledged scripting language. It could use a couple of built-in data
structures like lists and maps, and it certainly needs a core library for file
IO, user input etc. But the language itself is adequate. We&rsquo;ve got a little
procedural language in the same vein as BASIC, TCL, Scheme (minus macros), and
early versions of Python and Lua.</p>
<p>If this was the 80&rsquo;s, we&rsquo;d be done. But, today, many popular languages support
&ldquo;object-oriented programming&rdquo;. Adding that to Lox will give users a familiar set
of tools for writing larger programs. Even if you personally don&rsquo;t <span
name="hate">like</span> OOP, this chapter and the next will help you understand
how some language creators design and implement object systems.</p>
<aside name="hate">
<p>If you <em>really</em> hate classes, though, you can skip these chapters. They are
fairly separate from the rest of the book. Personally, I find it&rsquo;s good to learn
more about the things I dislike. I find things only seem all bad when viewed
from a distance. Once details emerge, I gain a more nuanced perspective.</p>
</aside>
<h3><a href="#oop-and-classes" name="oop-and-classes"><small>12&#8202;.&#8202;0&#8202;.&#8202;1</small> OOP and classes</a></h3>
<p>There are three broad paths to object-oriented programming: classes,
<a href="http://gameprogrammingpatterns.com/prototype.html">prototypes</a>, and <span name="multimethods"><a href="https://en.wikipedia.org/wiki/Multiple_dispatch">multimethods</a></span>. Classes
came first and are the most popular style. With the rise of JavaScript (and to a
lesser extent <a href="https://www.lua.org/pil/13.4.1.html">Lua</a>), prototypes are more widely known than they used to be.
I&rsquo;ll talk more about those <a href="#design-note">later</a>. For Lox, we&rsquo;re taking the, ahem, classic
approach.</p>
<aside name="multimethods">
<p>Multimethods are the one you&rsquo;re least likely to be familiar with. I&rsquo;d love to
talk more about them&#8202;&mdash;&#8202;I designed <a href="http://magpie-lang.org/">a hobby language</a> around them once
and they are <em>super rad</em>&#8202;&mdash;&#8202;but there are only so many pages I can fit in. If
you&rsquo;d like to learn more, take a look a CLOS (the object system in Common Lisp),
Dylan, Julia, or Perl 6.</p>
</aside>
<p>Since you&rsquo;ve written about a thousand lines of Java code with me already, I&rsquo;m
assuming you don&rsquo;t need a detailed introduction to object-orientation. The main
goal is to bundle data with the operations that act on it. Users do that by
declaring a <strong>class</strong> that:</p>
<ol>
<li>
<p>Exposes a <strong>constructor</strong> to create and initialize new <strong>instances</strong> of the
   class.</p>
</li>
<li>
<p>Provides a way to store and access <strong>fields</strong> on instances.</p>
</li>
<li>
<p>Defines a set of <strong>methods</strong> shared by all instances of the class that
   operate on their state.</p>
</li>
</ol>
<p>That&rsquo;s about as minimal as you can get. Most object-oriented languages, all the
way back to Simula, also do inheritance to share behavior across <em>classes</em>.
We&rsquo;ll add that in the <a href="inheritance.html">next chapter</a>. Even kicking that out, we
still have a lot to get through. This is a big chapter and everything doesn&rsquo;t
quite come together until we have all of the above pieces, so gather your
stamina.</p>
<h2><a href="#class-declarations" name="class-declarations"><small>12&#8202;.&#8202;1</small> Class Declarations</a></h2>
<p>Like we do, we&rsquo;re gonna start with syntax. Classes introduce a new named
declaration, so they get another clause in that grammar rule:</p>
<div class="codehilite"><pre><span></span><span class="n">declaration</span> <span class="err">→</span> <span class="n">classDecl</span>
            <span class="err">|</span> <span class="n">funDecl</span>
            <span class="err">|</span> <span class="n">varDecl</span>
            <span class="err">|</span> <span class="n">statement</span> <span class="p">;</span>
</pre></div>


<p>That&rsquo;s this new rule:</p>
<div class="codehilite"><pre><span></span><span class="n">classDecl</span>   <span class="err">→</span> <span class="s">&quot;class&quot;</span> <span class="vg">IDENTIFIER</span> <span class="s">&quot;{&quot;</span> <span class="n">function</span><span class="o">*</span> <span class="s">&quot;}&quot;</span> <span class="p">;</span>
</pre></div>


<p>That&rsquo;s the only new grammar. That rule relies on the <code>function</code> rule we defined
earlier. To refresh your memory:</p>
<div class="codehilite"><pre><span></span><span class="n">function</span>    <span class="err">→</span> <span class="vg">IDENTIFIER</span> <span class="s">&quot;(&quot;</span> <span class="n">parameters</span><span class="err">?</span> <span class="s">&quot;)&quot;</span> <span class="n">block</span> <span class="p">;</span>
<span class="n">parameters</span>  <span class="err">→</span> <span class="vg">IDENTIFIER</span> <span class="p">(</span> <span class="s">&quot;,&quot;</span> <span class="vg">IDENTIFIER</span> <span class="p">)</span><span class="o">*</span> <span class="p">;</span>
</pre></div>


<p>We also use that for named function declarations. Those wrap the <code>function</code> rule
in a <code>funDecl</code> one that requires a preceding <code>fun</code> keyword. <span
name="fun">Methods</span> skip that leading keyword. In plain English, a class
declaration is the <code>class</code> keyword, followed by the class&rsquo;s name, then a list of
method declarations surrounded by curly braces. Here&rsquo;s one:</p>
<aside name="fun">
<p>Not that I&rsquo;m trying to say methods aren&rsquo;t fun or anything.</p>
</aside>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="vg">Breakfast</span> <span class="p">{</span>
  <span class="n">cook</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">print</span> <span class="s">&quot;Eggs a-fryin&#39;!&quot;</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">serve</span><span class="p">(</span><span class="n">who</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">print</span> <span class="s">&quot;Enjoy your breakfast, &quot;</span> <span class="o">+</span> <span class="n">who</span> <span class="o">+</span> <span class="s">&quot;.&quot;</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>Like most dynamically-typed languages, fields are not explicitly listed in the
class declaration. Instances are loose bags of data and you can freely add
fields to them as you see fit in the middle of normal imperative code.</p>
<p>Over in our AST generator, the <code>classDecl</code> grammar rule becomes a statement
node:</p>
<div class="codehilite"><pre class="insert-before"><span></span>      <span class="s">&quot;Block      : List&lt;Stmt&gt; statements&quot;</span><span class="o">,</span>
</pre><div class="source-file"><em>tool/GenerateAst.java</em><br>
in <em>main</em>()</div>
<pre class="insert"><span></span>      <span class="s">&quot;Class      : Token name, List&lt;Stmt.Function&gt; methods&quot;</span><span class="o">,</span>
</pre><pre class="insert-after"><span></span>      <span class="s">&quot;Expression : Expr expression&quot;</span><span class="o">,</span>
</pre></div>

<p>It stores the name and the methods inside the body. We reuse the existing
Stmt.Function class that we use for function declaration AST nodes to represent
method declarations too since they have all the bits of state that we need&#8202;&mdash;&#8202;method name, parameter list, and body.</p>
<p>We can parse a class declaration anywhere a named declaration is allowed,
triggered by the leading <code>class</code> keyword:</p>
<div class="codehilite"><pre class="insert-before"><span></span>    <span class="k">try</span> <span class="o">{</span>
</pre><div class="source-file"><em>lox/Parser.java</em><br>
in <em>declaration</em>()</div>
<pre class="insert"><span></span>      <span class="k">if</span> <span class="o">(</span><span class="n">match</span><span class="o">(</span><span class="n">CLASS</span><span class="o">))</span> <span class="k">return</span> <span class="n">classDeclaration</span><span class="o">();</span>
</pre><pre class="insert-after"><span></span>      <span class="k">if</span> <span class="o">(</span><span class="n">match</span><span class="o">(</span><span class="n">FUN</span><span class="o">))</span> <span class="k">return</span> <span class="n">function</span><span class="o">(</span><span class="s">&quot;function&quot;</span><span class="o">);</span>
</pre></div>

<p>That calls out to:</p>
<div class="codehilite"><div class="source-file"><em>lox/Parser.java</em><br>
add after <em>declaration</em>()</div>
<pre><br><span></span>  <span class="kd">private</span> <span class="n">Stmt</span> <span class="nf">classDeclaration</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">Token</span> <span class="n">name</span> <span class="o">=</span> <span class="n">consume</span><span class="o">(</span><span class="n">IDENTIFIER</span><span class="o">,</span> <span class="s">&quot;Expect class name.&quot;</span><span class="o">);</span>
    <span class="n">consume</span><span class="o">(</span><span class="n">LEFT_BRACE</span><span class="o">,</span> <span class="s">&quot;Expect &#39;{&#39; before class body.&quot;</span><span class="o">);</span>

    <span class="n">List</span><span class="o">&lt;</span><span class="n">Stmt</span><span class="o">.</span><span class="na">Function</span><span class="o">&gt;</span> <span class="n">methods</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="k">while</span> <span class="o">(!</span><span class="n">check</span><span class="o">(</span><span class="n">RIGHT_BRACE</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">isAtEnd</span><span class="o">())</span> <span class="o">{</span>
      <span class="n">methods</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">function</span><span class="o">(</span><span class="s">&quot;method&quot;</span><span class="o">));</span>
    <span class="o">}</span>

    <span class="n">consume</span><span class="o">(</span><span class="n">RIGHT_BRACE</span><span class="o">,</span> <span class="s">&quot;Expect &#39;}&#39; after class body.&quot;</span><span class="o">);</span>

    <span class="k">return</span> <span class="k">new</span> <span class="n">Stmt</span><span class="o">.</span><span class="na">Class</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">methods</span><span class="o">);</span>
  <span class="o">}</span>
</pre></div>

<p>It&rsquo;s a little bigger than the parsing methods for most of our productions, but
it roughly corresponds to the grammar. We&rsquo;ve already consumed the <code>class</code>
keyword, so we look for the expected class name next, followed by the opening
curly brace for the class body. Then we keep parsing method declarations until
we hit the closing brace. Each method declaration is parsed by a call to
<code>function()</code>, which we defined back in the <a href="functions.html">chapter where functions were
introduced</a>.</p>
<p>Like we do in any open-ended loop in the parser, we also check for hitting the
end of the file. That won&rsquo;t happen in correct code since a class should have a
closing brace at the end, but it ensures the parser doesn&rsquo;t get stuck in an
infinite loop if the user has a syntax error and forgets to correctly end the
class body.</p>
<p>We wrap the name and list of methods up in a Stmt.Class node and we&rsquo;re done.
Usually, the next step would be interpretation, but now that we have that
resolution pass we need to go through that first:</p>
<div class="codehilite"><div class="source-file"><em>lox/Resolver.java</em><br>
add after <em>visitBlockStmt</em>()</div>
<pre><span></span>  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="n">Void</span> <span class="nf">visitClassStmt</span><span class="o">(</span><span class="n">Stmt</span><span class="o">.</span><span class="na">Class</span> <span class="n">stmt</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">declare</span><span class="o">(</span><span class="n">stmt</span><span class="o">.</span><span class="na">name</span><span class="o">);</span>
    <span class="n">define</span><span class="o">(</span><span class="n">stmt</span><span class="o">.</span><span class="na">name</span><span class="o">);</span>
    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
  <span class="o">}</span>
<br></pre></div>

<p>We aren&rsquo;t going to worry about resolving the methods themselves just yet, so for
now all we need to do is declare the class name itself. It&rsquo;s not common to
declare a class as a <em>local</em> variable, but Lox permits it, so we need to handle
that correctly.</p>
<p>After that, we interpret it:</p>
<div class="codehilite"><div class="source-file"><em>lox/Interpreter.java</em><br>
add after <em>visitBlockStmt</em>()</div>
<pre><span></span>  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="n">Void</span> <span class="nf">visitClassStmt</span><span class="o">(</span><span class="n">Stmt</span><span class="o">.</span><span class="na">Class</span> <span class="n">stmt</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">environment</span><span class="o">.</span><span class="na">define</span><span class="o">(</span><span class="n">stmt</span><span class="o">.</span><span class="na">name</span><span class="o">.</span><span class="na">lexeme</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
    <span class="n">LoxClass</span> <span class="n">klass</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LoxClass</span><span class="o">(</span><span class="n">stmt</span><span class="o">.</span><span class="na">name</span><span class="o">.</span><span class="na">lexeme</span><span class="o">);</span>
    <span class="n">environment</span><span class="o">.</span><span class="na">assign</span><span class="o">(</span><span class="n">stmt</span><span class="o">.</span><span class="na">name</span><span class="o">,</span> <span class="n">klass</span><span class="o">);</span>
    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
  <span class="o">}</span>
</pre></div>

<p>This looks similar to how we interpret function declarations. We declare the
class&rsquo;s name in the current environment. Then we turn the class <em>syntax node</em>
into a LoxClass, the <em>runtime</em> representation of a class. We circle back and
store the class object in the variable we already declared. As with function
declarations, that two-stage variable binding process allows referring to a
class inside the bodies of its methods.</p>
<p>It will grow throughout this chapter, but the first draft of our class&rsquo;s runtime
manifestation looks like so:</p>
<div class="codehilite"><div class="source-file"><em>lox/LoxClass.java</em><br>
create new file</div>
<pre><span></span><span class="kn">package</span> <span class="nn">com.craftinginterpreters.lox</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Map</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">LoxClass</span> <span class="o">{</span>
  <span class="kd">final</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>

  <span class="n">LoxClass</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="n">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">name</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>

<p>Literally a wrapper around a name. We don&rsquo;t even store the methods yet. Not
super useful, but it does have a <code>toString()</code> method so we can write a little
script and test that class objects are actually being parsed and executed:</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="vg">DevonshireCream</span> <span class="p">{</span>
  <span class="n">serveOn</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s">&quot;Scones&quot;</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">print</span> <span class="vg">DevonshireCream</span><span class="p">;</span> <span class="c1">// Prints &quot;DevonshireCream&quot;.</span>
</pre></div>


<h2><a href="#creating-instances" name="creating-instances"><small>12&#8202;.&#8202;2</small> Creating Instances</a></h2>
<p>We have classes, but they don&rsquo;t <em>do</em> anything yet. Lox doesn&rsquo;t have &ldquo;static&rdquo;
methods that you can call right on the class itself, so without actual
instances, classes are pretty useless. Thus instances are the next step.</p>
<p>While some syntax and semantics are fairly standard across OOP languages, the
way you create new instances isn&rsquo;t. Ruby, following Smalltalk, places
construction as a method on the class object itself, a <span
name="turtles">recursively</span> graceful approach. Some, like C++ and Java
have a <code>new</code> keyword dedicated to birthing a new object. Python has you &ldquo;call&rdquo;
the class itself like a function. (JavaScript, ever weird, sort of does both of
the latter.)</p>
<aside name="turtles">
<p>In Smalltalk, even <em>classes</em> are created by calling methods on an existing
object, usually the desired superclass. It&rsquo;s sort of a turtles-all-the-way down
thing. It ultimately bottoms out on a few magical classes like Object and
Metaclass that the runtime conjures into being <em>ex nihilo</em>.</p>
</aside>
<p>I took a minimal approach with Lox. We already have class objects, and we
already have function calls, so we&rsquo;ll use call expressions on class objects to
create new instances. It&rsquo;s as if a class is a factory function that generates
instances of itself. This feels elegant to me, and also spares us the need to
introduce syntax like <code>new</code>. Therefore, we can skip past the front end right
into the runtime.</p>
<p>Right now, if you try this:</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="vg">Bagel</span> <span class="p">{}</span>
<span class="vg">Bagel</span><span class="p">();</span>
</pre></div>


<p>You get a runtime error. <code>visitCallExpr()</code> checks to see if the called object
implements <code>LoxCallable</code> and reports an error since LoxClass doesn&rsquo;t. Not <em>yet</em>,
that is:</p>
<div class="codehilite"><pre class="insert-before"><span></span><span class="kn">import</span> <span class="nn">java.util.Map</span><span class="o">;</span>
<br></pre><div class="source-file"><em>lox/LoxClass.java</em><br>
in class <em>LoxClass</em><br>
replace 1 line</div>
<pre class="insert"><span></span><span class="kd">class</span> <span class="nc">LoxClass</span> <span class="kd">implements</span> <span class="n">LoxCallable</span> <span class="o">{</span>
</pre><pre class="insert-after"><span></span>  <span class="kd">final</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
</pre></div>

<p>That interface requires two methods. The interesting one is <code>call()</code>:</p>
<div class="codehilite"><div class="source-file"><em>lox/LoxClass.java</em><br>
add after <em>toString</em>()</div>
<pre><span></span>  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="n">Object</span> <span class="nf">call</span><span class="o">(</span><span class="n">Interpreter</span> <span class="n">interpreter</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span> <span class="n">arguments</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">LoxInstance</span> <span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LoxInstance</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">instance</span><span class="o">;</span>
  <span class="o">}</span>
</pre></div>

<p>When you &ldquo;call&rdquo; a class, it instantiates a new LoxInstance for the called class
and returns it. LoxCallable also requires one other helper method:</p>
<div class="codehilite"><div class="source-file"><em>lox/LoxClass.java</em><br>
add after <em>toString</em>()</div>
<pre><span></span>  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">arity</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
  <span class="o">}</span>
</pre></div>

<p>This is how <code>visitCallExpr()</code> checks to see if you passed the right number of
arguments to it. For now, we&rsquo;ll say that you can&rsquo;t pass any. When we get to
user-defined constructors, we&rsquo;ll revisit this.</p>
<p>The remaining piece is LoxInstance, our runtime representation of an instance of
a Lox class. Again, our first iteration starts small:</p>
<div class="codehilite"><div class="source-file"><em>lox/LoxInstance.java</em><br>
create new file</div>
<pre><span></span><span class="kn">package</span> <span class="nn">com.craftinginterpreters.lox</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.HashMap</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Map</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">LoxInstance</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="n">LoxClass</span> <span class="n">klass</span><span class="o">;</span>

  <span class="n">LoxInstance</span><span class="o">(</span><span class="n">LoxClass</span> <span class="n">klass</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">klass</span> <span class="o">=</span> <span class="n">klass</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="n">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">klass</span><span class="o">.</span><span class="na">name</span> <span class="o">+</span> <span class="s">&quot; instance&quot;</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>

<p>Like LoxClass, it&rsquo;s pretty bare bones, but we&rsquo;re only getting started. If you
want to give it a try, here&rsquo;s a script to run:</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="vg">Bagel</span> <span class="p">{}</span>
<span class="k">var</span> <span class="n">bagel</span> <span class="o">=</span> <span class="vg">Bagel</span><span class="p">();</span>
<span class="k">print</span> <span class="n">bagel</span><span class="p">;</span> <span class="c1">// Prints &quot;Bagel instance&quot;.</span>
</pre></div>


<p>It doesn&rsquo;t do much, but it&rsquo;s starting to do <em>something</em>.</p>
<h2><a href="#properties-on-instances" name="properties-on-instances"><small>12&#8202;.&#8202;3</small> Properties on Instances</a></h2>
<p>We have instances, so we should make them useful. We&rsquo;re at a fork in the road.
We could add behavior first&#8202;&mdash;&#8202;methods&#8202;&mdash;&#8202;or we could start with state&#8202;&mdash;&#8202;properties. We&rsquo;re going to take the latter because, as we&rsquo;ll see, the two get
entangled in an interesting way and it will be easier to make sense of them if
we get properties working first.</p>
<p>Lox follows JavaScript and Python in how it handles state. Every instance is a
loose bag of named data. Methods on the instance&rsquo;s class can access and modify
those properties, but so can <span name="outside">outside</span> code.
Properties are accessed using a <code>.</code> syntax:</p>
<aside name="outside">
<p>Allowing code outside of the class to directly modify an object&rsquo;s state goes
against the object-oriented credo that a class <em>encapsulates</em> state. Some
languages take a more principled state. In Smalltalk, there is no syntax for
directly modifying the state of an object. Instead, fields are accessed using
simple identifiers, essentially variables that are only in scope inside the
class&rsquo;s methods. Ruby uses <code>@</code> followed by a name to access a field in an
object. That syntax is only meaningful inside a method and always accesses state
on the current object.</p>
<p>Lox, for better or worse, isn&rsquo;t quite so pious about its OOP faith.</p>
</aside>
<div class="codehilite"><pre><span></span><span class="n">someObject</span><span class="p">.</span><span class="n">someProperty</span>
</pre></div>


<p>An expression followed by a <code>.</code> and an identifier reads the property with that
name from the object the expression evaluates to. That <code>.</code> is as high precedence
as the parentheses in a function call expression, so we slot it into the grammar
by replacing the existing <code>call</code> rule with:</p>
<div class="codehilite"><pre><span></span><span class="n">call</span> <span class="err">→</span> <span class="n">primary</span> <span class="p">(</span> <span class="s">&quot;(&quot;</span> <span class="n">arguments</span><span class="err">?</span> <span class="s">&quot;)&quot;</span> <span class="err">|</span> <span class="s">&quot;.&quot;</span> <span class="vg">IDENTIFIER</span> <span class="p">)</span><span class="o">*</span> <span class="p">;</span>
</pre></div>


<p>After a primary expression, we allow a series of any mixture of parenthesized
calls and dotted property accesses. &ldquo;Property access&rdquo; is a mouthful, so from
here on out, we&rsquo;ll call these &ldquo;get expressions&rdquo;.</p>
<h3><a href="#get-expressions" name="get-expressions"><small>12&#8202;.&#8202;3&#8202;.&#8202;1</small> Get expressions</a></h3>
<p>The syntax tree node is:</p>
<div class="codehilite"><pre class="insert-before"><span></span>      <span class="s">&quot;Call     : Expr callee, Token paren, List&lt;Expr&gt; arguments&quot;</span><span class="o">,</span>
</pre><div class="source-file"><em>tool/GenerateAst.java</em><br>
in <em>main</em>()</div>
<pre class="insert"><span></span>      <span class="s">&quot;Get      : Expr object, Token name&quot;</span><span class="o">,</span>
</pre><pre class="insert-after"><span></span>      <span class="s">&quot;Grouping : Expr expression&quot;</span><span class="o">,</span>
</pre></div>

<p>Following the grammar, the new parsing code goes in our existing <code>call()</code>
method:</p>
<div class="codehilite"><pre class="insert-before"><span></span>    <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">match</span><span class="o">(</span><span class="n">LEFT_PAREN</span><span class="o">))</span> <span class="o">{</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">finishCall</span><span class="o">(</span><span class="n">expr</span><span class="o">);</span>
</pre><div class="source-file"><em>lox/Parser.java</em><br>
in <em>call</em>()</div>
<pre class="insert"><span></span>      <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">match</span><span class="o">(</span><span class="n">DOT</span><span class="o">))</span> <span class="o">{</span>
        <span class="n">Token</span> <span class="n">name</span> <span class="o">=</span> <span class="n">consume</span><span class="o">(</span><span class="n">IDENTIFIER</span><span class="o">,</span>
            <span class="s">&quot;Expect property name after &#39;.&#39;.&quot;</span><span class="o">);</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Expr</span><span class="o">.</span><span class="na">Get</span><span class="o">(</span><span class="n">expr</span><span class="o">,</span> <span class="n">name</span><span class="o">);</span>
</pre><pre class="insert-after"><span></span>      <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
        <span class="k">break</span><span class="o">;</span>
      <span class="o">}</span>
    <span class="o">}</span>
</pre></div>

<p>The outer while loop there corresponds to the <code>*</code> in the grammar rule. We zip
along the tokens building up a chain of calls and gets as we find parentheses
and dots.</p>
<p><strong>todo: illustrate</strong></p>
<p>That new node feeds into the resolver:</p>
<div class="codehilite"><div class="source-file"><em>lox/Resolver.java</em><br>
add after <em>visitCallExpr</em>()</div>
<pre><span></span>  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="n">Void</span> <span class="nf">visitGetExpr</span><span class="o">(</span><span class="n">Expr</span><span class="o">.</span><span class="na">Get</span> <span class="n">expr</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">resolve</span><span class="o">(</span><span class="n">expr</span><span class="o">.</span><span class="na">object</span><span class="o">);</span>
    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
  <span class="o">}</span>
<br></pre></div>

<p>OK, not much to that. Since properties are themselves looked up <span
name="dispatch">dynamically</span>, they don&rsquo;t get resolved. All we do is
recurse into the expression to the left of the dot. The actual work happens in
the interpreter:</p>
<aside name="dispatch">
<p>Here you can literally see that property dispatch in Lox is dynamic since we
don&rsquo;t process any of it here in the static resolution pass.</p>
</aside>
<div class="codehilite"><div class="source-file"><em>lox/Interpreter.java</em><br>
add after <em>visitCallExpr</em>()</div>
<pre><span></span>  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="n">Object</span> <span class="nf">visitGetExpr</span><span class="o">(</span><span class="n">Expr</span><span class="o">.</span><span class="na">Get</span> <span class="n">expr</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">Object</span> <span class="n">object</span> <span class="o">=</span> <span class="n">evaluate</span><span class="o">(</span><span class="n">expr</span><span class="o">.</span><span class="na">object</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">object</span> <span class="k">instanceof</span> <span class="n">LoxInstance</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">return</span> <span class="o">((</span><span class="n">LoxInstance</span><span class="o">)</span> <span class="n">object</span><span class="o">).</span><span class="na">get</span><span class="o">(</span><span class="n">expr</span><span class="o">.</span><span class="na">name</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="k">throw</span> <span class="k">new</span> <span class="n">RuntimeError</span><span class="o">(</span><span class="n">expr</span><span class="o">.</span><span class="na">name</span><span class="o">,</span>
        <span class="s">&quot;Only instances have properties.&quot;</span><span class="o">);</span>
  <span class="o">}</span>
</pre></div>

<p>First, we evaluate the expression whose property is being accessed. In Lox, only
instances of classes have properties. If the object is some other type like a
number, trying to access a property on it is a runtime error.</p>
<p>If the object <em>is</em> a LoxInstance, then we ask it to look up the property
property. Looks like it&rsquo;s time to give LoxInstance some actual state. A map will
do fine:</p>
<div class="codehilite"><pre class="insert-before"><span></span>  <span class="kd">private</span> <span class="n">LoxClass</span> <span class="n">klass</span><span class="o">;</span>
</pre><div class="source-file"><em>lox/LoxInstance.java</em><br>
in class <em>LoxInstance</em></div>
<pre class="insert"><span></span>  <span class="kd">private</span> <span class="kd">final</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Object</span><span class="o">&gt;</span> <span class="n">fields</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;&gt;();</span>
</pre><pre class="insert-after"><br><span></span>  <span class="n">LoxInstance</span><span class="o">(</span><span class="n">LoxClass</span> <span class="n">klass</span><span class="o">)</span> <span class="o">{</span>
</pre></div>

<p>Each key in the map is the name of a property name and the corresponding value
is the property&rsquo;s value. To look up a property on an instance:</p>
<div class="codehilite"><div class="source-file"><em>lox/LoxInstance.java</em><br>
add after <em>LoxInstance</em>()</div>
<pre><span></span>  <span class="n">Object</span> <span class="nf">get</span><span class="o">(</span><span class="n">Token</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">fields</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">name</span><span class="o">.</span><span class="na">lexeme</span><span class="o">))</span> <span class="o">{</span>
      <span class="k">return</span> <span class="n">fields</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">name</span><span class="o">.</span><span class="na">lexeme</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="k">throw</span> <span class="k">new</span> <span class="n">RuntimeError</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span name="hidden"></span>
        <span class="s">&quot;Undefined property &#39;&quot;</span> <span class="o">+</span> <span class="n">name</span><span class="o">.</span><span class="na">lexeme</span> <span class="o">+</span> <span class="s">&quot;&#39;.&quot;</span><span class="o">);</span>
  <span class="o">}</span>
</pre></div>

<aside name="hidden">
<p>Doing a hash table lookup for every field access is fast enough for many
language implementations, but not ideal. High performance VMs for languages like
JavaScript use sophisticated optimizations like &ldquo;<a href="http://richardartoul.github.io/jekyll/update/2015/04/26/hidden-classes.html">hidden classes</a>&rdquo; to avoid
that overhead.</p>
<p>Interestingly, many of the optimizations invented to make highly dynamic
languages fast rest on the observation that&#8202;&mdash;&#8202;even in those languages&#8202;&mdash;&#8202;most
code is fairly static in terms of the types of objects it works with and their
shapes.</p>
</aside>
<p>An interesting edge case we need to handle is what happens if the instance
doesn&rsquo;t <em>have</em> a property with the given name. We could silently return some
dummy value like <code>nil</code>, but my feeling is that that to mask bugs more often than
it does something useful. Instead, we&rsquo;ll make it a runtime error.</p>
<p>So the first thing we do is see if the instance actually has a field with the
given name. Only then does it return it. Otherwise, it raises an error.</p>
<p>Note how I switched from talking about &ldquo;properties&rdquo; to &ldquo;fields&rdquo;. There is a
subtle difference between the two. Fields are named bits of state stored
directly in an instance. Properties are the named, uh, <em>things</em>, that you can
access on an instance. Every field is a property, but as we&rsquo;ll see <span
name="foreshadowing">later</span>, not every property is a field.</p>
<aside name="foreshadowing">
<p>Ooh, foreshadowing. Spooky!</p>
</aside>
<p>In theory, we can now read properties on objects. But since there&rsquo;s no way to
actually stuff any state into an instance, there are no fields to access. Before
we can test out reading, we must support writing.</p>
<h3><a href="#set-expressions" name="set-expressions"><small>12&#8202;.&#8202;3&#8202;.&#8202;2</small> Set expressions</a></h3>
<p>Setters use the same syntax as getters, except they appear on the left side of
an assignment:</p>
<div class="codehilite"><pre><span></span><span class="n">someObject</span><span class="p">.</span><span class="n">someProperty</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
</pre></div>


<p>To keep grammar up to date, we extend rule for assignment to allow dotted
identifiers on the left-hand side:</p>
<div class="codehilite"><pre><span></span><span class="n">assignment</span> <span class="err">→</span> <span class="p">(</span> <span class="n">call</span> <span class="s">&quot;.&quot;</span> <span class="p">)</span><span class="err">?</span> <span class="vg">IDENTIFIER</span> <span class="s">&quot;=&quot;</span> <span class="n">assignment</span>
           <span class="err">|</span> <span class="n">logic_or</span><span class="p">;</span>
</pre></div>


<p>We don&rsquo;t need to explicitly allow a chain of setters. The reference to <code>call</code>
allows any high precedence expression before the last <code>.</code>, including a series of
other <code>.</code>, as in:</p>
<div class="codehilite"><pre><span></span><span class="n">a</span><span class="p">.</span><span class="n">b</span><span class="p">.</span><span class="n">c</span><span class="p">.</span><span class="n">d</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span>
</pre></div>


<p><strong>todo: illustrate mapped to grammar?</strong></p>
<p>Note here that only the <em>last</em> part, the <code>.d</code> is the <em>setter</em>. The <code>.b</code> and <code>.c</code>
are both <em>get</em> expressions.</p>
<p>Like we have two separate AST nodes for variable access and variable assignment,
we need a second node for property assignment:</p>
<div class="codehilite"><pre class="insert-before"><span></span>      <span class="s">&quot;Logical  : Expr left, Token operator, Expr right&quot;</span><span class="o">,</span>
</pre><div class="source-file"><em>tool/GenerateAst.java</em><br>
in <em>main</em>()</div>
<pre class="insert"><span></span>      <span class="s">&quot;Set      : Expr object, Token name, Expr value&quot;</span><span class="o">,</span>
</pre><pre class="insert-after"><span></span>      <span class="s">&quot;Unary    : Token operator, Expr right&quot;</span><span class="o">,</span>
</pre></div>

<p>In case you don&rsquo;t remember, the way we handle assignment in the parser is a
little funny. We can&rsquo;t easily tell that a series of tokens is the left-hand side
of an assignment until we reach the <code>=</code>. Now that our assignment grammar rule
has <code>call</code> on the left side, which can expand to arbitrarily large expressions,
that is hard for the parser to predict.</p>
<p>Instead, the trick we do is to parse the left hand side as a normal expression.
Then, when we stumble onto the equals sign, we take the expression we already
parsed and transform it into the correct syntax tree node for the assignment.</p>
<p>We add another clause to that transformation to handle turning an Expr.Get
expression on the left into the corresponding Expr.Set:</p>
<div class="codehilite"><pre class="insert-before"><span></span>        <span class="k">return</span> <span class="k">new</span> <span class="n">Expr</span><span class="o">.</span><span class="na">Assign</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
</pre><div class="source-file"><em>lox/Parser.java</em><br>
in <em>assignment</em>()</div>
<pre class="insert"><span></span>      <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">expr</span> <span class="k">instanceof</span> <span class="n">Expr</span><span class="o">.</span><span class="na">Get</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Expr</span><span class="o">.</span><span class="na">Get</span> <span class="n">get</span> <span class="o">=</span> <span class="o">(</span><span class="n">Expr</span><span class="o">.</span><span class="na">Get</span><span class="o">)</span><span class="n">expr</span><span class="o">;</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">Expr</span><span class="o">.</span><span class="na">Set</span><span class="o">(</span><span class="n">get</span><span class="o">.</span><span class="na">object</span><span class="o">,</span> <span class="n">get</span><span class="o">.</span><span class="na">name</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
</pre><pre class="insert-after"><span></span>      <span class="o">}</span>
</pre></div>

<p>That&rsquo;s our syntax. We push that through into the resolver:</p>
<div class="codehilite"><div class="source-file"><em>lox/Resolver.java</em><br>
add after <em>visitLogicalExpr</em>()</div>
<pre><span></span>  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="n">Void</span> <span class="nf">visitSetExpr</span><span class="o">(</span><span class="n">Expr</span><span class="o">.</span><span class="na">Set</span> <span class="n">expr</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">resolve</span><span class="o">(</span><span class="n">expr</span><span class="o">.</span><span class="na">value</span><span class="o">);</span>
    <span class="n">resolve</span><span class="o">(</span><span class="n">expr</span><span class="o">.</span><span class="na">object</span><span class="o">);</span>
    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
  <span class="o">}</span>
<br></pre></div>

<p>Again, like Expr.Get, the property itself is dynamically evaluated, so there&rsquo;s
nothing to resolve there. All we need to do is recurse into the two
subexpressions of Expr.Set, the object whose property is being set, and the
value it&rsquo;s being set to.</p>
<p>That leads us to the interpreter:</p>
<div class="codehilite"><div class="source-file"><em>lox/Interpreter.java</em><br>
add after <em>visitLogicalExpr</em>()</div>
<pre><span></span>  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="n">Object</span> <span class="nf">visitSetExpr</span><span class="o">(</span><span class="n">Expr</span><span class="o">.</span><span class="na">Set</span> <span class="n">expr</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">Object</span> <span class="n">object</span> <span class="o">=</span> <span class="n">evaluate</span><span class="o">(</span><span class="n">expr</span><span class="o">.</span><span class="na">object</span><span class="o">);</span>

    <span class="k">if</span> <span class="o">(!(</span><span class="n">object</span> <span class="k">instanceof</span> <span class="n">LoxInstance</span><span class="o">))</span> <span class="o">{</span> <span name="order"></span>
      <span class="k">throw</span> <span class="k">new</span> <span class="n">RuntimeError</span><span class="o">(</span><span class="n">expr</span><span class="o">.</span><span class="na">name</span><span class="o">,</span> <span class="s">&quot;Only instances have fields.&quot;</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="n">Object</span> <span class="n">value</span> <span class="o">=</span> <span class="n">evaluate</span><span class="o">(</span><span class="n">expr</span><span class="o">.</span><span class="na">value</span><span class="o">);</span>
    <span class="o">((</span><span class="n">LoxInstance</span><span class="o">)</span><span class="n">object</span><span class="o">).</span><span class="na">set</span><span class="o">(</span><span class="n">expr</span><span class="o">.</span><span class="na">name</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">value</span><span class="o">;</span>
  <span class="o">}</span>
</pre></div>

<p>We evaluate the object whose property is being set and we check to see if it&rsquo;s a
LoxInstance. If not, that&rsquo;s a runtime error. Otherwise, we evaluate the value
being set and store it on the instance. That relies on:</p>
<aside name="order">
<p>This is another semantic edge case. There are three distinct operations:</p>
<ol>
<li>Evaluate the object.</li>
<li>Raise a runtime error if it&rsquo;s not an instance of a class.</li>
<li>Evaluate the value.</li>
</ol>
<p>The order that those are performed could be user visible, which means we need to
carefully specify it and ensure our implementations do these in the same order.
Otherwise an implementation that, say, evaluated the value before the object
could break a user&rsquo;s program.</p>
</aside>
<div class="codehilite"><div class="source-file"><em>lox/LoxInstance.java</em><br>
add after <em>get</em>()</div>
<pre><span></span>  <span class="kt">void</span> <span class="nf">set</span><span class="o">(</span><span class="n">Token</span> <span class="n">name</span><span class="o">,</span> <span class="n">Object</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">fields</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">name</span><span class="o">.</span><span class="na">lexeme</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
  <span class="o">}</span>
</pre></div>

<p>No real magic here. We go straight to the Java map in the instance where fields
are stored.</p>
<h2><a href="#methods-on-classes" name="methods-on-classes"><small>12&#8202;.&#8202;4</small> Methods on Classes</a></h2>
<p>You can create instances of classes and stuff data into them. But the class
itself doesn&rsquo;t really <em>do</em> anything. Instances are just maps and all instances
are more or less the same. To make them feel like instances <em>of classes</em>, we
need behavior&#8202;&mdash;&#8202;methods.</p>
<p>Our helpful parser already parses method declarations, so we&rsquo;re good there. We
also don&rsquo;t need to add any new parser support for method <em>calls</em>. We already
have <code>.</code> (getters) and <code>()</code> (function calls). A &ldquo;method call&rdquo; simply chains
those together:</p>
<div class="codehilite"><pre><span></span><span class="n">object</span><span class="p">.</span><span class="n">method</span><span class="p">(</span><span class="n">argument</span><span class="p">);</span>
</pre></div>


<p>That raises an interesting question. What happens when those two expressions are
pulled apart? Assuming <code>method</code> is a method on the class of <code>object</code> and not a
field on the instance, what would this do:</p>
<div class="codehilite"><pre><span></span><span class="k">var</span> <span class="n">m</span> <span class="o">=</span> <span class="n">object</span><span class="p">.</span><span class="n">method</span><span class="p">;</span>
<span class="n">m</span><span class="p">(</span><span class="n">argument</span><span class="p">);</span>
</pre></div>


<p>This program &ldquo;looks up&rdquo; the method and stores the result&#8202;&mdash;&#8202;whatever that is&#8202;&mdash;&#8202;in a variable and then calls that object later. Is this allowed? Can you treat a
method like it&rsquo;s a function on the instance?</p>
<p>What about the other direction?</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="vg">Box</span> <span class="p">{}</span>

<span class="k">fun</span> <span class="n">notMethod</span><span class="p">(</span><span class="n">argument</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">print</span> <span class="s">&quot;called function with &quot;</span> <span class="o">+</span> <span class="n">argument</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">var</span> <span class="n">box</span> <span class="o">=</span> <span class="vg">Box</span><span class="p">();</span>
<span class="n">box</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">notMethod</span><span class="p">;</span>
<span class="n">box</span><span class="p">.</span><span class="n">function</span><span class="p">(</span><span class="s">&quot;argument&quot;</span><span class="p">);</span>
</pre></div>


<p>This program creates an instance and then stores a function in a field on it.
Then it calls that function using the same syntax as a method call. Does that
work?</p>
<p>Different languages have different answers to these questions. One could write a
treatise on it. For Lox, we&rsquo;ll say the answer to both of these is that, yes, it
does work. We have a couple of reasons to justify that. For the second example,
calling a function stored in a field, we want to support that because first
class functions are useful and storing them in fields is a perfectly normal
thing to do.</p>
<p>The first example is more complex. One motivation to support it is that users
generally expect to be able to hoist a subexpression out into a local variable
without changing the meaning of the program. You can take this:</p>
<div class="codehilite"><pre><span></span><span class="k">var</span> <span class="n">average</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
</pre></div>


<p>And turn it into this:</p>
<div class="codehilite"><pre><span></span><span class="k">var</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">4</span><span class="p">;</span>
<span class="k">var</span> <span class="n">average</span> <span class="o">=</span> <span class="n">sum</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
</pre></div>


<p>And it does the same thing. Likewise, we&rsquo;d like to let you hoist the method
<em>lookup</em> part of a method call out into a variable and then use that to call it
later. We need to think carefully about what the <em>thing</em> you get when you look
up a method is, and how it behaves. Stuff like this:</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="vg">Person</span> <span class="p">{</span>
  <span class="n">sayName</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">print</span> <span class="nb">this</span><span class="p">.</span><span class="n">name</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">var</span> <span class="n">jane</span> <span class="o">=</span> <span class="vg">Person</span><span class="p">();</span>
<span class="n">jane</span><span class="p">.</span><span class="n">name</span> <span class="s">&quot;jane&quot;</span><span class="p">;</span>

<span class="k">var</span> <span class="n">method</span> <span class="o">=</span> <span class="n">jane</span><span class="p">.</span><span class="n">sayName</span><span class="p">;</span>
<span class="n">method</span><span class="p">();</span> <span class="c1">// ?</span>
</pre></div>


<p>If you grab a handle to a method on some instance and call it later, does it
&ldquo;remember&rdquo; the instance it was pulled off from? Does <code>this</code> inside the method
still refer to that original instance?</p>
<p>Here&rsquo;s a more pathological example to wrap your head around:</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="vg">Person</span> <span class="p">{</span>
  <span class="n">sayName</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">print</span> <span class="nb">this</span><span class="p">.</span><span class="n">name</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">var</span> <span class="n">jane</span> <span class="o">=</span> <span class="vg">Person</span><span class="p">();</span>
<span class="n">jane</span><span class="p">.</span><span class="n">name</span> <span class="s">&quot;jane&quot;</span><span class="p">;</span>

<span class="k">var</span> <span class="n">bill</span> <span class="o">=</span> <span class="vg">Person</span><span class="p">();</span>
<span class="n">bill</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;bill&quot;</span><span class="p">;</span>

<span class="n">bill</span><span class="p">.</span><span class="n">sayName</span> <span class="o">=</span> <span class="n">jane</span><span class="p">.</span><span class="n">sayName</span><span class="p">;</span>
<span class="n">bill</span><span class="p">.</span><span class="n">sayName</span><span class="p">();</span> <span class="c1">// ?</span>
</pre></div>


<p>Does that last line print &ldquo;bill&rdquo; because that&rsquo;s the instance that we <em>called</em>
the method through, or &ldquo;jane&rdquo; because it&rsquo;s the instance where we first grabbed
the method?</p>
<p>Equivalent code in Lua and JavaScript would print &ldquo;bill&rdquo;. Those languages don&rsquo;t
really have a notion of &ldquo;methods&rdquo;. Everything is sort of functions-in-fields, so
it&rsquo;s not clear that <code>jane</code> &ldquo;owns&rdquo; <code>sayName</code> any more than <code>bill</code> does.</p>
<p>Lox, though, has real class syntax so we do know which callable things are
methods and which are functions. Thus, like Python, C#, and others, we will have
methods &ldquo;bind&rdquo; <code>this</code> to the original instance when the method is first grabbed.
Python calls these &ldquo;bound methods&rdquo;.</p>
<p>In practice, that&rsquo;s usually what you want. If you take a reference to a method
on some object so you can use it as a callback later, you want that call to
remember the instance it belonged to, even if that callback happens to be stored
in a field in some other random object.</p>
<p>OK, that&rsquo;s a lot of semantics to load into your head. Forget about the edge
cases for a bit. We&rsquo;ll get back to those. For now, let&rsquo;s get basic method calls
working. We&rsquo;re already parsing the method declarations inside the class body, so
the next step is to resolve them:</p>
<div class="codehilite"><pre class="insert-before"><span></span>    <span class="n">define</span><span class="o">(</span><span class="n">stmt</span><span class="o">.</span><span class="na">name</span><span class="o">);</span>
</pre><div class="source-file"><em>lox/Resolver.java</em><br>
in <em>visitClassStmt</em>()</div>
<pre class="insert"><br><span></span>    <span class="k">for</span> <span class="o">(</span><span class="n">Stmt</span><span class="o">.</span><span class="na">Function</span> <span class="n">method</span> <span class="o">:</span> <span class="n">stmt</span><span class="o">.</span><span class="na">methods</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">FunctionType</span> <span class="n">declaration</span> <span class="o">=</span> <span class="n">FunctionType</span><span class="o">.</span><span class="na">METHOD</span><span class="o">;</span>
      <span class="n">resolveFunction</span><span class="o">(</span><span class="n">method</span><span class="o">,</span> <span class="n">declaration</span><span class="o">);</span> <span name="local"></span>
    <span class="o">}</span>
<br></pre><pre class="insert-after"><span></span>    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
</pre></div>

<aside name="local">
<p>Storing the function type in a local variable is pointless right now, but we&rsquo;ll
expand this code before too long and it will make more sense.</p>
</aside>
<p>We iterate through the methods in the class body and call the
<code>resolveFunction()</code> method we wrote for handling function declarations already.
The only difference is that we pass in a new FunctionType enum value:</p>
<div class="codehilite"><pre class="insert-before"><span></span>    <span class="n">NONE</span><span class="o">,</span>
</pre><div class="source-file"><em>lox/Resolver.java</em><br>
add after <em>Resolver</em>()<br>
replace 1 line</div>
<pre class="insert"><span></span>    <span class="n">FUNCTION</span><span class="o">,</span>
    <span class="n">METHOD</span>
</pre><pre class="insert-after"><span></span>  <span class="o">}</span>
</pre></div>

<p>That&rsquo;s going to be important when we resolve <code>this</code> expressions. For now, don&rsquo;t
worry about it. The interesting stuff is in the interpreter:</p>
<div class="codehilite"><pre class="insert-before"><span></span>    <span class="n">environment</span><span class="o">.</span><span class="na">define</span><span class="o">(</span><span class="n">stmt</span><span class="o">.</span><span class="na">name</span><span class="o">.</span><span class="na">lexeme</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
</pre><div class="source-file"><em>lox/Interpreter.java</em><br>
in <em>visitClassStmt</em>()<br>
replace 1 line</div>
<pre class="insert"><span></span>    <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">LoxFunction</span><span class="o">&gt;</span> <span class="n">methods</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;&gt;();</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">Stmt</span><span class="o">.</span><span class="na">Function</span> <span class="n">method</span> <span class="o">:</span> <span class="n">stmt</span><span class="o">.</span><span class="na">methods</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">LoxFunction</span> <span class="n">function</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LoxFunction</span><span class="o">(</span><span class="n">method</span><span class="o">,</span> <span class="n">environment</span><span class="o">);</span>
      <span class="n">methods</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">method</span><span class="o">.</span><span class="na">name</span><span class="o">.</span><span class="na">lexeme</span><span class="o">,</span> <span class="n">function</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="n">LoxClass</span> <span class="n">klass</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LoxClass</span><span class="o">(</span><span class="n">stmt</span><span class="o">.</span><span class="na">name</span><span class="o">.</span><span class="na">lexeme</span><span class="o">,</span> <span class="n">methods</span><span class="o">);</span>
</pre><pre class="insert-after"><span></span>    <span class="n">environment</span><span class="o">.</span><span class="na">assign</span><span class="o">(</span><span class="n">stmt</span><span class="o">.</span><span class="na">name</span><span class="o">,</span> <span class="n">klass</span><span class="o">);</span>
</pre></div>

<p>When we interpret a class declaration statement, we turn the syntactic
representation of the class&#8202;&mdash;&#8202;its AST node&#8202;&mdash;&#8202;into its runtime representation.
Now, we need to do that for the methods contained in the class as well. Each
method declaration blossoms into a LoxFunction object.</p>
<p>We take all of those and wrap them up into a map, keyed by the method names.
That gets stored in LoxClass:</p>
<div class="codehilite"><pre class="insert-before"><span></span>  <span class="kd">final</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
</pre><div class="source-file"><em>lox/LoxClass.java</em><br>
in class <em>LoxClass</em><br>
replace 4 lines</div>
<pre class="insert"><span></span>  <span class="kd">private</span> <span class="kd">final</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">LoxFunction</span><span class="o">&gt;</span> <span class="n">methods</span><span class="o">;</span>

  <span class="n">LoxClass</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">,</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">LoxFunction</span><span class="o">&gt;</span> <span class="n">methods</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">methods</span> <span class="o">=</span> <span class="n">methods</span><span class="o">;</span>
  <span class="o">}</span>
</pre><pre class="insert-after"><br><span></span>  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="n">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
</pre></div>

<p>Where an instance stores state, the class stores behavior. LoxInstance has its
map of fields. LoxClass gets a map of methods.</p>
<p>Even though methods are defined on the class, they are still accessed through
the instances of that class:</p>
<div class="codehilite"><pre class="insert-before"><span></span>  <span class="n">Object</span> <span class="nf">get</span><span class="o">(</span><span class="n">Token</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">fields</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">name</span><span class="o">.</span><span class="na">lexeme</span><span class="o">))</span> <span class="o">{</span>
      <span class="k">return</span> <span class="n">fields</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">name</span><span class="o">.</span><span class="na">lexeme</span><span class="o">);</span>
    <span class="o">}</span>
<br></pre><div class="source-file"><em>lox/LoxInstance.java</em><br>
in <em>get</em>()</div>
<pre class="insert"><span></span>    <span class="n">LoxFunction</span> <span class="n">method</span> <span class="o">=</span> <span class="n">klass</span><span class="o">.</span><span class="na">findMethod</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">name</span><span class="o">.</span><span class="na">lexeme</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">method</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="n">method</span><span class="o">;</span>
<br></pre><pre class="insert-after"><span></span>    <span class="k">throw</span> <span class="k">new</span> <span class="n">RuntimeError</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span name="hidden"></span>
        <span class="s">&quot;Undefined property &#39;&quot;</span> <span class="o">+</span> <span class="n">name</span><span class="o">.</span><span class="na">lexeme</span> <span class="o">+</span> <span class="s">&quot;&#39;.&quot;</span><span class="o">);</span>
</pre></div>

<p>When looking up a property on an instance, if we don&rsquo;t <span
name="shadow">find</span> a matching field, we look for a method with that name
on the instance&rsquo;s class. If found, we return that. This is where the distinction
between &ldquo;field&rdquo; and &ldquo;property&rdquo; becomes meaningful. When accessing a property,
you might get a field&#8202;&mdash;&#8202;a bit of state stored on the instance&#8202;&mdash;&#8202;or you could
hit a method defined on the instance&rsquo;s class.</p>
<p>The method is looked up using:</p>
<aside name="shadow">
<p>This implies that fields shadow methods, a subtle but important semantic point.</p>
</aside>
<div class="codehilite"><div class="source-file"><em>lox/LoxClass.java</em><br>
add after <em>LoxClass</em>()</div>
<pre><span></span>  <span class="n">LoxFunction</span> <span class="nf">findMethod</span><span class="o">(</span><span class="n">LoxInstance</span> <span class="n">instance</span><span class="o">,</span> <span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">methods</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">name</span><span class="o">))</span> <span class="o">{</span>
      <span class="k">return</span> <span class="n">methods</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
  <span class="o">}</span>
</pre></div>

<p>You can probably guess this method is going to get more interesting later. We
pass in the instance, but we aren&rsquo;t using it yet. For now, a simple map lookup
on the class&rsquo;s method table is enough to get us started.</p>
<p>Give it a try:</p>
<p><span name="crunch"></span></p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="vg">Bacon</span> <span class="p">{</span>
  <span class="n">eat</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">print</span> <span class="s">&quot;Crunch crunch crunch!&quot;</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="vg">Bacon</span><span class="p">().</span><span class="n">eat</span><span class="p">();</span> <span class="c1">// Prints &quot;Crunch crunch crunch!&quot;.</span>
</pre></div>


<aside name="crunch">
<p>Apologies if you prefer chewy bacon over crunchy. Feel free to adjust the script
to your taste.</p>
</aside>
<h2><a href="#this" name="this"><small>12&#8202;.&#8202;5</small> This</a></h2>
<p>We can define both behavior and state on objects, but they aren&rsquo;t tied together
yet. Inside a method, there is no way to access the fields of the &ldquo;current&rdquo;
object&#8202;&mdash;&#8202;the instance that the method was called on&#8202;&mdash;&#8202;nor can you call other
methods on that same object.</p>
<p>We need a <span name="i">name</span> to use to refer that current object.
Smalltalk, Ruby, and Swift use &ldquo;self&rdquo;. Simula, C++, Java, and others use &ldquo;this&rdquo;.
Python uses &ldquo;self&rdquo; by convention, but you can technically use whatever name your
like.</p>
<aside name="i">
<p>&ldquo;I&rdquo; would have been a great choice, but using &ldquo;i&rdquo; for loop variables predates
OOP and goes all the way back to Fortran. We are victims of the incidental
choices of our forebears.</p>
</aside>
<p>For Lox, since we generally hew to Java-ish style, we&rsquo;ll do &ldquo;this&rdquo;. Inside a
method body, a <code>this</code> expression evaluates to the instance that the method was
called on. Or, more specifically, since methods are accessed and then invoked as
two steps, it will refer to the object that the method was <em>accessed</em> from.</p>
<p>The interpreter&rsquo;s challenge is to remember current instance when the method is
looked up and hang onto it for later when the method object is called. It&rsquo;s
almost like <code>this</code> is a special hidden argument that gets passed to the method
when you call it. That analogy breaks down, though, since <code>this</code> needs to be
&ldquo;passed in&rdquo; and pinned down even before the method is actually <em>called</em>.</p>
<p>But that intuition hints at a promising approach. We already have environments
and closures that let a function hang onto some state as long its needs it. If
we could stuff <code>this</code> into that surrounding environment, the function would be
able to find it when called later.</p>
<p><strong>todo: illustrate</strong></p>
<p>The trick is that we &ldquo;pass in <code>this</code>&rdquo; when the method is looked up while
evaluating the <code>.</code> expression. That creates a closure for the method that binds
<code>this</code> to the current receiver. When the closure is later called, any uses of
<code>this</code> inside its body find that bound receiver.</p>
<p>Reusing our existing machinery for managing environments to handle <code>this</code> also
takes care of interesting cases where methods and functions nest and interact,
like:</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="vg">Outer</span> <span class="p">{</span>
  <span class="n">method</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">class</span> <span class="vg">Inner</span> <span class="p">{</span>
      <span class="n">method</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// Inner this should shadow outer this.</span>
        <span class="k">print</span> <span class="nb">this</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>Since class declarations are statements, they can nest (though realistic code
rarely does this). When that happens, we need to make sure the two different
uses of <code>this</code> shadow each other correctly.</p>
<p>A more useful tricky example is:</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="vg">Thing</span> <span class="p">{</span>
  <span class="n">getCallback</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">fun</span> <span class="n">localFunction</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">print</span> <span class="nb">this</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">localFunction</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">var</span> <span class="n">callback</span> <span class="o">=</span> <span class="vg">Thing</span><span class="p">().</span><span class="n">getCallback</span><span class="p">();</span>
<span class="n">callback</span><span class="p">();</span>
</pre></div>


<p>In, say, JavaScript, it&rsquo;s common to return a callback from inside a method. That
callback may want to hang onto and retain access to the original object the
method was associated with. Our existing support for closures and environment
chains should do all this correctly.</p>
<p>The first step is adding new syntax for <code>this</code>:</p>
<div class="codehilite"><pre class="insert-before"><span></span>      <span class="s">&quot;Set      : Expr object, Token name, Expr value&quot;</span><span class="o">,</span>
</pre><div class="source-file"><em>tool/GenerateAst.java</em><br>
in <em>main</em>()</div>
<pre class="insert"><span></span>      <span class="s">&quot;This     : Token keyword&quot;</span><span class="o">,</span>
</pre><pre class="insert-after"><span></span>      <span class="s">&quot;Unary    : Token operator, Expr right&quot;</span><span class="o">,</span>
</pre></div>

<p>Instead of making it a reserved word, we could treat <code>this</code> as simply an
identifier that gets a predefined value. However, that would allow bad code
like:</p>
<div class="codehilite"><pre><span></span><span class="k">var</span> <span class="nb">this</span> <span class="o">=</span> <span class="s">&quot;wat&quot;</span><span class="p">;</span> <span class="c1">// Declare a variable with that name.</span>
<span class="nb">this</span> <span class="o">=</span> <span class="c1">// Assign to it.</span>
<span class="k">fun</span> <span class="nb">this</span><span class="p">()</span> <span class="p">{}</span> <span class="c1">// Use it as a function name?!</span>
</pre></div>


<p>The simplest way to rule all of that out is to make it a keyword so that it
can&rsquo;t be parsed as an identifier. Then we add a new syntax node for an
expression that <em>accesses</em> <code>this</code>, which is the only thing we want to allow you
to do with it.</p>
<p>Parsing is simple since it&rsquo;s a single token:</p>
<div class="codehilite"><pre class="insert-before"><span></span>      <span class="k">return</span> <span class="k">new</span> <span class="n">Expr</span><span class="o">.</span><span class="na">Literal</span><span class="o">(</span><span class="n">previous</span><span class="o">().</span><span class="na">literal</span><span class="o">);</span>
    <span class="o">}</span>
</pre><div class="source-file"><em>lox/Parser.java</em><br>
in <em>primary</em>()</div>
<pre class="insert"><br><span></span>    <span class="k">if</span> <span class="o">(</span><span class="n">match</span><span class="o">(</span><span class="n">THIS</span><span class="o">))</span> <span class="k">return</span> <span class="k">new</span> <span class="n">Expr</span><span class="o">.</span><span class="na">This</span><span class="o">(</span><span class="n">previous</span><span class="o">());</span>
</pre><pre class="insert-after"><br><span></span>    <span class="k">if</span> <span class="o">(</span><span class="n">match</span><span class="o">(</span><span class="n">IDENTIFIER</span><span class="o">))</span> <span class="o">{</span>
</pre></div>

<p>You can start to see how <code>this</code> works like a variable when we get to the
resolver:</p>
<div class="codehilite"><div class="source-file"><em>lox/Resolver.java</em><br>
add after <em>visitSetExpr</em>()</div>
<pre><span></span>  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="n">Void</span> <span class="nf">visitThisExpr</span><span class="o">(</span><span class="n">Expr</span><span class="o">.</span><span class="na">This</span> <span class="n">expr</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">resolveLocal</span><span class="o">(</span><span class="n">expr</span><span class="o">,</span> <span class="n">expr</span><span class="o">.</span><span class="na">keyword</span><span class="o">);</span>
    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
  <span class="o">}</span>
<br></pre></div>

<p>We resolve it exactly like any other local variable using &ldquo;this&rdquo; as the name for
the &ldquo;variable&rdquo;. Of course, that&rsquo;s not going to work right now, because &ldquo;this&rdquo;
<em>isn&rsquo;t</em> declared in any scope. Let&rsquo;s fix that over in <code>visitClassStmt()</code>:</p>
<div class="codehilite"><pre class="insert-before"><span></span>    <span class="n">define</span><span class="o">(</span><span class="n">stmt</span><span class="o">.</span><span class="na">name</span><span class="o">);</span>
<br></pre><div class="source-file"><em>lox/Resolver.java</em><br>
in <em>visitClassStmt</em>()</div>
<pre class="insert"><span></span>    <span class="n">beginScope</span><span class="o">();</span>
    <span class="n">scopes</span><span class="o">.</span><span class="na">peek</span><span class="o">().</span><span class="na">put</span><span class="o">(</span><span class="s">&quot;this&quot;</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>
<br></pre><pre class="insert-after"><span></span>    <span class="k">for</span> <span class="o">(</span><span class="n">Stmt</span><span class="o">.</span><span class="na">Function</span> <span class="n">method</span> <span class="o">:</span> <span class="n">stmt</span><span class="o">.</span><span class="na">methods</span><span class="o">)</span> <span class="o">{</span>
</pre></div>

<p>Before we step in and start resolving the method bodies, we push a new scope and
define &ldquo;this&rdquo; in it as if it were a variable. Then, when we&rsquo;re done, we discard
it:</p>
<div class="codehilite"><pre class="insert-before"><span></span>    <span class="o">}</span>
<br></pre><div class="source-file"><em>lox/Resolver.java</em><br>
in <em>visitClassStmt</em>()</div>
<pre class="insert"><span></span>    <span class="n">endScope</span><span class="o">();</span>
<br></pre><pre class="insert-after"><span></span>    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
</pre></div>

<p>Now, whenever a <code>this</code> expression is encountered (at least inside a method) it
will resolve to a &ldquo;local variable&rdquo; defined in an implicit scope just outside of
the block for the method body.</p>
<p><strong>todo: illustrate</strong></p>
<p>The resolver has a new <em>scope</em> for <code>this</code>, so the interpreter needs to create a
corresponding environment for it at runtime. Remember, we always have to keep
the resolver&rsquo;s scope chains and the interpreter&rsquo;s linked environments in sync
with each other. At runtime, we create the environment when the method is looked
up on the instance. We replace the previous line of code that simply returned
the LoxFunction with this:</p>
<div class="codehilite"><pre class="insert-before"><span></span>    <span class="k">if</span> <span class="o">(</span><span class="n">methods</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">name</span><span class="o">))</span> <span class="o">{</span>
</pre><div class="source-file"><em>lox/LoxClass.java</em><br>
in <em>findMethod</em>()<br>
replace 1 line</div>
<pre class="insert"><span></span>      <span class="k">return</span> <span class="n">methods</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">name</span><span class="o">).</span><span class="na">bind</span><span class="o">(</span><span class="n">instance</span><span class="o">);</span>
</pre><pre class="insert-after"><span></span>    <span class="o">}</span>
</pre></div>

<p>Note the new call to <code>bind()</code>. That looks like this:</p>
<div class="codehilite"><div class="source-file"><em>lox/LoxFunction.java</em><br>
add after <em>LoxFunction</em>()</div>
<pre><span></span>  <span class="n">LoxFunction</span> <span class="nf">bind</span><span class="o">(</span><span class="n">LoxInstance</span> <span class="n">instance</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">Environment</span> <span class="n">environment</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Environment</span><span class="o">(</span><span class="n">closure</span><span class="o">);</span>
    <span class="n">environment</span><span class="o">.</span><span class="na">define</span><span class="o">(</span><span class="s">&quot;this&quot;</span><span class="o">,</span> <span class="n">instance</span><span class="o">);</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">LoxFunction</span><span class="o">(</span><span class="n">declaration</span><span class="o">,</span> <span class="n">environment</span><span class="o">);</span>
  <span class="o">}</span>
</pre></div>

<p>There isn&rsquo;t much to it. We create a new environment nestled inside the method&rsquo;s
original closure environment. Sort of a closure-within-a-closure. When the
method is called, that will become the parent method body&rsquo;s environment.</p>
<p><strong>todo: illustrate</strong></p>
<p>We declare &ldquo;this&rdquo; as a variable in that environment and bind it to the given
instance, the same instance that the method is being accessed from. <em>Et voil&agrave;</em>,
the returned LoxFunction now carries around its own little persistent world
where &ldquo;this&rdquo; is bound to the object.</p>
<hr />
<p><strong>todo: spelling</strong></p>
<p>The remaining task is interpreting those <code>this</code> expressions. Similar to the
resolver, interpreting a <code>this</code> expression is the same as interpreting a
variable expression:</p>
<div class="codehilite"><div class="source-file"><em>lox/Interpreter.java</em><br>
add after <em>visitSetExpr</em>()</div>
<pre><span></span>  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="n">Object</span> <span class="nf">visitThisExpr</span><span class="o">(</span><span class="n">Expr</span><span class="o">.</span><span class="na">This</span> <span class="n">expr</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">lookUpVariable</span><span class="o">(</span><span class="n">expr</span><span class="o">.</span><span class="na">keyword</span><span class="o">,</span> <span class="n">expr</span><span class="o">);</span>
  <span class="o">}</span>
</pre></div>

<p>Go ahead and give it a try:</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="vg">Cake</span> <span class="p">{</span>
  <span class="n">taste</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">print</span> <span class="s">&quot;The &quot;</span> <span class="o">+</span> <span class="nb">this</span><span class="p">.</span><span class="n">flavor</span> <span class="o">+</span> <span class="s">&quot; cake is delicious!&quot;</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">var</span> <span class="n">cake</span> <span class="o">=</span> <span class="vg">Cake</span><span class="p">();</span>
<span class="n">cake</span><span class="p">.</span><span class="n">flavor</span> <span class="o">=</span> <span class="s">&quot;German chocolate&quot;</span><span class="p">;</span>

<span class="k">var</span> <span class="n">taste</span> <span class="o">=</span> <span class="n">cake</span><span class="p">.</span><span class="n">taste</span><span class="p">;</span>
<span class="n">taste</span><span class="p">();</span> <span class="c1">// Prints &quot;The German chocolate cake is delicious!&quot;.</span>
</pre></div>


<p>Virtual high fives all-around. Our interpreter handles <code>this</code> inside methods
even in all of the weird ways it can interact with nested classes, functions
inside methods, handles to methods, etc.</p>
<p>But what happens if you try to use <code>this</code> <em>outside</em> of a method? What about:</p>
<div class="codehilite"><pre><span></span><span class="k">print</span> <span class="nb">this</span><span class="p">;</span>
</pre></div>


<p>Or:</p>
<div class="codehilite"><pre><span></span><span class="k">fun</span> <span class="n">notAMethod</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">print</span> <span class="nb">this</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<h3><a href="#invalid-uses-of-this" name="invalid-uses-of-this"><small>12&#8202;.&#8202;5&#8202;.&#8202;1</small> Invalid uses of this</a></h3>
<p>There is no instance for <code>this</code> to point to if you&rsquo;re not in a method. We could
give it some default value like <code>nil</code> or make it a runtime error, but the user
has clearly made a mistake. The sooner they find and fix that mistake, the
happier they&rsquo;ll be.</p>
<p>Our resolution pass is a fine place to detect this error statically. It already
detects return statements outside of functions. We&rsquo;ll do something similar for
<code>this</code>. In the vein of our existing FunctionType enum, we define a new ClassType
one:</p>
<div class="codehilite"><pre class="insert-before"><span></span>  <span class="o">}</span>
</pre><div class="source-file"><em>lox/Resolver.java</em><br>
add after <em>Resolver</em>()</div>
<pre class="insert"><br><span></span>  <span class="kd">private</span> <span class="kd">enum</span> <span class="n">ClassType</span> <span class="o">{</span>
    <span class="n">NONE</span><span class="o">,</span>
    <span class="n">CLASS</span>
  <span class="o">}</span>

  <span class="kd">private</span> <span class="n">ClassType</span> <span class="n">currentClass</span> <span class="o">=</span> <span class="n">ClassType</span><span class="o">.</span><span class="na">NONE</span><span class="o">;</span>
<br></pre><pre class="insert-after"><span></span>  <span class="kt">void</span> <span class="nf">resolve</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Stmt</span><span class="o">&gt;</span> <span class="n">statements</span><span class="o">)</span> <span class="o">{</span>
</pre></div>

<p>Yes, it could be a Boolean. When we get to inheritance, it will get a third
value, hence the enum right now. We also add a corresponding field,
<code>currentClass</code>. Its value tells us if we are currently inside a class while
traversing the syntax tree. It starts out <code>NONE</code> which means we aren&rsquo;t inside a
class.</p>
<p>We change that before resolving the method bodies in a class declaration:</p>
<div class="codehilite"><pre class="insert-before"><span></span>    <span class="n">define</span><span class="o">(</span><span class="n">stmt</span><span class="o">.</span><span class="na">name</span><span class="o">);</span>
</pre><div class="source-file"><em>lox/Resolver.java</em><br>
in <em>visitClassStmt</em>()</div>
<pre class="insert"><span></span>    <span class="n">ClassType</span> <span class="n">enclosingClass</span> <span class="o">=</span> <span class="n">currentClass</span><span class="o">;</span>
    <span class="n">currentClass</span> <span class="o">=</span> <span class="n">ClassType</span><span class="o">.</span><span class="na">CLASS</span><span class="o">;</span>
</pre><pre class="insert-after"><br><span></span>    <span class="n">beginScope</span><span class="o">();</span>
</pre></div>

<p>As with <code>currentFunction</code>, we store the previous value of the field in a local
variable. This lets us piggyback onto the JVM to keep a stack of <code>currentClass</code>
values. That way we don&rsquo;t lose track of the earlier state when one class nests
inside another.</p>
<p>Once the methods have been resolved, we &ldquo;pop&rdquo; that stack by restoring the
previous value:</p>
<div class="codehilite"><pre class="insert-before"><br><span></span>    <span class="n">endScope</span><span class="o">();</span>
<br></pre><div class="source-file"><em>lox/Resolver.java</em><br>
in <em>visitClassStmt</em>()</div>
<pre class="insert"><span></span>    <span class="n">currentClass</span> <span class="o">=</span> <span class="n">enclosingClass</span><span class="o">;</span>
</pre><pre class="insert-after"><span></span>    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
</pre></div>

<p>When we resolve a <code>this</code> expression, that gives us the bit of data we need to
report an error if the expression doesn&rsquo;t occur nestled inside a method body:</p>
<div class="codehilite"><pre class="insert-before"><span></span>  <span class="kd">public</span> <span class="n">Void</span> <span class="nf">visitThisExpr</span><span class="o">(</span><span class="n">Expr</span><span class="o">.</span><span class="na">This</span> <span class="n">expr</span><span class="o">)</span> <span class="o">{</span>
</pre><div class="source-file"><em>lox/Resolver.java</em><br>
in <em>visitThisExpr</em>()</div>
<pre class="insert"><span></span>    <span class="k">if</span> <span class="o">(</span><span class="n">currentClass</span> <span class="o">==</span> <span class="n">ClassType</span><span class="o">.</span><span class="na">NONE</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">Lox</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="n">expr</span><span class="o">.</span><span class="na">keyword</span><span class="o">,</span>
          <span class="s">&quot;Cannot use &#39;this&#39; outside of a class.&quot;</span><span class="o">);</span>
      <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
<br></pre><pre class="insert-after"><span></span>    <span class="n">resolveLocal</span><span class="o">(</span><span class="n">expr</span><span class="o">,</span> <span class="n">expr</span><span class="o">.</span><span class="na">keyword</span><span class="o">);</span>
</pre></div>

<p>That should help users use <code>this</code> correctly and saves us from having to handle
misuse at runtime in the interpreter.</p>
<h2><a href="#constructors-and-initializers" name="constructors-and-initializers"><small>12&#8202;.&#8202;6</small> Constructors and Initializers</a></h2>
<p>We can do almost everything with classes now, and all that remains as we near
the end of the chapter is the beginning. Methods and fields let us encapsulate
state and behavior together so that an object always <em>stays</em> in a valid
configuration. But how do we ensure a brand new object <em>begins</em> in a meaningful
state?</p>
<p>For that, we need constructors. I find them one of the trickiest parts of a
language to design and if you peer closely at other most languages, you&rsquo;ll see
<span name="cracks">cracks</span> around object construction where the seams of
the design don&rsquo;t quite hang together perfectly. Maybe there&rsquo;s something
intrinsically messy about the moment of birth.</p>
<aside name="cracks">
<p>A few examples: In Java, even though final fields must be initialized, it is
still possible to read one <em>before</em> it has been. Exceptions&#8202;&mdash;&#8202;a huge, complex
feature&#8202;&mdash;&#8202;were added to C++ mainly as a way to emit errors from constructors.
Take a look at how weird the original syntaxes in Python and JavaScript were.</p>
</aside>
<p>&ldquo;Constructing&rdquo; an object is actually a pair of operations:</p>
<ol>
<li>
<p>The runtime <span name="allocate"><em>allocates</em></span> the memory required for
    a fresh instance. In most languages, this operation is at a fundamental
    level beneath what user code is able to access.</p>
<aside markdown="1" name="allocate">

<p>C++&rsquo;s &ldquo;<a href="https://en.wikipedia.org/wiki/Placement_syntax">placement new</a>&rdquo; is a rare example where the bowels of allocation
are laid bare for the programmer to poke and prod.</p>
</aside>

</li>
<li>
<p>Then a user-provided chunk of code is called which <em>initializes</em> the
    unformed object.</p>
</li>
</ol>
<p>The latter is what we tend to think of when we think of &ldquo;constructors&rdquo;, but the
language itself has usually done some ground work for us first before we get to
that point. In fact, our Lox interpreter already has that covered when it
creates a new LoxInstance object.</p>
<p>We&rsquo;ll do the remaining part&#8202;&mdash;&#8202;user-defined initialization&#8202;&mdash;&#8202;now. Languages
have a variety of notations for the chunk of code that sets up a new object for
a class. C++, Java, and C# use a method whose name matches the class name. Ruby
and Python call it <code>init()</code>. That&rsquo;s nice and short, so we&rsquo;ll do that.</p>
<p>The basic idea is that when you call a class, the interpreter allocates a new
instance. Then, if the class has defined a method named &ldquo;init&rdquo;, it calls that.
Any arguments passed when calling the class are forwarded on to this
initializer:</p>
<div class="codehilite"><pre class="insert-before"><span></span>    <span class="n">LoxInstance</span> <span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LoxInstance</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
</pre><div class="source-file"><em>lox/LoxClass.java</em><br>
in <em>call</em>()</div>
<pre class="insert"><span></span>    <span class="n">LoxFunction</span> <span class="n">initializer</span> <span class="o">=</span> <span class="n">methods</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">&quot;init&quot;</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">initializer</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">initializer</span><span class="o">.</span><span class="na">bind</span><span class="o">(</span><span class="n">instance</span><span class="o">).</span><span class="na">call</span><span class="o">(</span><span class="n">interpreter</span><span class="o">,</span> <span class="n">arguments</span><span class="o">);</span>
    <span class="o">}</span>
<br></pre><pre class="insert-after"><span></span>    <span class="k">return</span> <span class="n">instance</span><span class="o">;</span>
</pre></div>

<p>When a class is called, after the LoxInstance is created, we look for an <span
name="reserve">&ldquo;init&rdquo;</span> method. If we find one, we immediately bind and
invoke it just like a normal method call. The argument list is forwarded along.</p>
<aside name="reserve">
<p>Unlike, &ldquo;this&rdquo;, we are not going to make &ldquo;init&rdquo; a reserved word since allowing
user to use it as an identifier doesn&rsquo;t open up the same pitfalls that treating
&ldquo;this&rdquo; like an identifier does.</p>
</aside>
<p>That argument list means we also need to tweak how a class declares its arity:</p>
<div class="codehilite"><pre class="insert-before"><span></span>  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">arity</span><span class="o">()</span> <span class="o">{</span>
</pre><div class="source-file"><em>lox/LoxClass.java</em><br>
in <em>arity</em>()<br>
replace 1 line</div>
<pre class="insert"><span></span>    <span class="n">LoxFunction</span> <span class="n">initializer</span> <span class="o">=</span> <span class="n">methods</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">&quot;init&quot;</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">initializer</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">return</span> <span class="n">initializer</span><span class="o">.</span><span class="na">arity</span><span class="o">();</span>
</pre><pre class="insert-after"><span></span>  <span class="o">}</span>
</pre></div>

<p>If there is an initializer, that method&rsquo;s arity determines the class&rsquo;s. We don&rsquo;t
<em>require</em> a class to define an initializer, though, as a convenience. If you
don&rsquo;t have one, the arity is still zero.</p>
<h3><a href="#invoking-init()-directly" name="invoking-init()-directly"><small>12&#8202;.&#8202;6&#8202;.&#8202;1</small> Invoking init() directly</a></h3>
<p>As ever, exploring this new semantic territory rustles up a few weird creatures.
Consider:</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="vg">Foo</span> <span class="p">{</span>
  <span class="n">init</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">print</span> <span class="nb">this</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">var</span> <span class="n">foo</span> <span class="o">=</span> <span class="vg">Foo</span><span class="p">();</span>
<span class="k">print</span> <span class="n">foo</span><span class="p">.</span><span class="n">init</span><span class="p">();</span>
</pre></div>


<p>Can you &ldquo;re-initialize&rdquo; an object by directly calling its <code>init()</code> method? If
you do, what does it return? A <span name="compromise">reasonable</span> answer
would be <code>nil</code> since that&rsquo;s what it appears the body does. However&#8202;&mdash;&#8202;and I
usually dislike compromising to satisfy the implementation&#8202;&mdash;&#8202;it will make
clox&rsquo;s implementation of constructors much easier if we say that <code>init()</code>
methods implicitly return <code>this</code>, even when directly called.</p>
<aside name="compromise">
<p>Maybe &ldquo;dislike&rdquo; is too strong a claim. It&rsquo;s reasonable to have the constraints
and resources of your implementation affect the design of the language. There
are only so many hours in the day and if a cut corner here or there lets you get
more features to users in less time, it may very well be a net win for their
happiness and productivity. The trick is figuring out <em>which</em> corners to cut
that won&rsquo;t cause your future self to curse your short-sightedness.</p>
</aside>
<p>In order to keep jlox compatible with that, we add a little special case code in
LoxFunction:</p>
<div class="codehilite"><pre class="insert-before"><span></span>      <span class="k">return</span> <span class="n">returnValue</span><span class="o">.</span><span class="na">value</span><span class="o">;</span>
    <span class="o">}</span>
</pre><div class="source-file"><em>lox/LoxFunction.java</em><br>
in <em>call</em>()</div>
<pre class="insert"><br><span></span>    <span class="k">if</span> <span class="o">(</span><span class="n">isInitializer</span><span class="o">)</span> <span class="k">return</span> <span class="n">closure</span><span class="o">.</span><span class="na">getAt</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="s">&quot;this&quot;</span><span class="o">);</span>
</pre><pre class="insert-after"><span></span>    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
</pre></div>

<p>If the function is an initializer, we override the actual return value and
forcibly return <code>this</code>. That relies on a new <code>isInitializer</code> field:</p>
<div class="codehilite"><pre class="insert-before"><span></span>  <span class="kd">private</span> <span class="kd">final</span> <span class="n">Environment</span> <span class="n">closure</span><span class="o">;</span>
</pre><div class="source-file"><em>lox/LoxFunction.java</em><br>
in class <em>LoxFunction</em><br>
replace 1 line</div>
<pre class="insert"><span></span>  <span class="kd">private</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="n">isInitializer</span><span class="o">;</span>

  <span class="n">LoxFunction</span><span class="o">(</span><span class="n">Stmt</span><span class="o">.</span><span class="na">Function</span> <span class="n">declaration</span><span class="o">,</span> <span class="n">Environment</span> <span class="n">closure</span><span class="o">,</span>
              <span class="kt">boolean</span> <span class="n">isInitializer</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">isInitializer</span> <span class="o">=</span> <span class="n">isInitializer</span><span class="o">;</span>
</pre><pre class="insert-after"><span></span>    <span class="k">this</span><span class="o">.</span><span class="na">closure</span> <span class="o">=</span> <span class="n">closure</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">declaration</span> <span class="o">=</span> <span class="n">declaration</span><span class="o">;</span>
</pre></div>

<p>We can&rsquo;t simply see if the name of the LoxFunction is &ldquo;init&rdquo; because the user
could have defined a <em>function</em> with that name. In that case, there <em>is</em> no
<code>this</code> to return. Instead, we&rsquo;ll directly store whether the LoxFunction
represents an initializer method. That means we need to go back and fix the few
places where we create a LoxFunction:</p>
<div class="codehilite"><pre class="insert-before"><span></span>  <span class="kd">public</span> <span class="n">Void</span> <span class="nf">visitFunctionStmt</span><span class="o">(</span><span class="n">Stmt</span><span class="o">.</span><span class="na">Function</span> <span class="n">stmt</span><span class="o">)</span> <span class="o">{</span>
</pre><div class="source-file"><em>lox/Interpreter.java</em><br>
in <em>visitFunctionStmt</em>()<br>
replace 1 line</div>
<pre class="insert"><span></span>    <span class="n">LoxFunction</span> <span class="n">function</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LoxFunction</span><span class="o">(</span><span class="n">stmt</span><span class="o">,</span> <span class="n">environment</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
</pre><pre class="insert-after"><span></span>    <span class="n">environment</span><span class="o">.</span><span class="na">define</span><span class="o">(</span><span class="n">stmt</span><span class="o">.</span><span class="na">name</span><span class="o">.</span><span class="na">lexeme</span><span class="o">,</span> <span class="n">function</span><span class="o">);</span>
</pre></div>

<p>For actual functions, <code>isInitializer</code> is always false. For methods, we check the
name:</p>
<div class="codehilite"><pre class="insert-before"><span></span>    <span class="k">for</span> <span class="o">(</span><span class="n">Stmt</span><span class="o">.</span><span class="na">Function</span> <span class="n">method</span> <span class="o">:</span> <span class="n">stmt</span><span class="o">.</span><span class="na">methods</span><span class="o">)</span> <span class="o">{</span>
</pre><div class="source-file"><em>lox/Interpreter.java</em><br>
in <em>visitClassStmt</em>()<br>
replace 1 line</div>
<pre class="insert"><span></span>      <span class="n">LoxFunction</span> <span class="n">function</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LoxFunction</span><span class="o">(</span><span class="n">method</span><span class="o">,</span> <span class="n">environment</span><span class="o">,</span>
          <span class="n">method</span><span class="o">.</span><span class="na">name</span><span class="o">.</span><span class="na">lexeme</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">&quot;init&quot;</span><span class="o">));</span>
</pre><pre class="insert-after"><span></span>      <span class="n">methods</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">method</span><span class="o">.</span><span class="na">name</span><span class="o">.</span><span class="na">lexeme</span><span class="o">,</span> <span class="n">function</span><span class="o">);</span>
</pre></div>

<p>And then in <code>bind()</code> where we create the closure that binds <code>this</code> to a method,
we pass along the original method&rsquo;s value:</p>
<div class="codehilite"><pre class="insert-before"><span></span>    <span class="n">environment</span><span class="o">.</span><span class="na">define</span><span class="o">(</span><span class="s">&quot;this&quot;</span><span class="o">,</span> <span class="n">instance</span><span class="o">);</span>
</pre><div class="source-file"><em>lox/LoxFunction.java</em><br>
in <em>bind</em>()<br>
replace 1 line</div>
<pre class="insert"><span></span>    <span class="k">return</span> <span class="k">new</span> <span class="n">LoxFunction</span><span class="o">(</span><span class="n">declaration</span><span class="o">,</span> <span class="n">environment</span><span class="o">,</span> <span class="n">isInitializer</span><span class="o">);</span>
</pre><pre class="insert-after"><span></span>  <span class="o">}</span>
</pre></div>

<h3><a href="#returning-from-init()" name="returning-from-init()"><small>12&#8202;.&#8202;6&#8202;.&#8202;2</small> Returning from init()</a></h3>
<p>We aren&rsquo;t out of the woods yet. We&rsquo;ve been assuming here that a user-written
initializer doesn&rsquo;t explicitly return a value because most constructors don&rsquo;t.
What happens if a user tries:</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="vg">Foo</span> <span class="p">{</span>
  <span class="n">init</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s">&quot;something else&quot;</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>It&rsquo;s definitely not going to do what they want, so we may as well make it a
static error. Back in the resolver, we add another case to FunctionType:</p>
<div class="codehilite"><pre class="insert-before"><span></span>    <span class="n">FUNCTION</span><span class="o">,</span>
</pre><div class="source-file"><em>lox/Resolver.java</em><br>
add after <em>Resolver</em>()</div>
<pre class="insert"><span></span>    <span class="n">INITIALIZER</span><span class="o">,</span>
</pre><pre class="insert-after"><span></span>    <span class="n">METHOD</span>
</pre></div>

<p>When resolving a method, we look at the name to determine if we&rsquo;re resolving an
initializer or some other normal method:</p>
<div class="codehilite"><pre class="insert-before"><span></span>      <span class="n">FunctionType</span> <span class="n">declaration</span> <span class="o">=</span> <span class="n">FunctionType</span><span class="o">.</span><span class="na">METHOD</span><span class="o">;</span>
</pre><div class="source-file"><em>lox/Resolver.java</em><br>
in <em>visitClassStmt</em>()</div>
<pre class="insert"><span></span>      <span class="k">if</span> <span class="o">(</span><span class="n">method</span><span class="o">.</span><span class="na">name</span><span class="o">.</span><span class="na">lexeme</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">&quot;init&quot;</span><span class="o">))</span> <span class="o">{</span>
        <span class="n">declaration</span> <span class="o">=</span> <span class="n">FunctionType</span><span class="o">.</span><span class="na">INITIALIZER</span><span class="o">;</span>
      <span class="o">}</span>
<br></pre><pre class="insert-after"><span></span>      <span class="n">resolveFunction</span><span class="o">(</span><span class="n">method</span><span class="o">,</span> <span class="n">declaration</span><span class="o">);</span> <span name="local"></span>
</pre></div>

<p>We check that field and make it an error to have a return statement with a value
inside an <code>init()</code> method:</p>
<div class="codehilite"><pre class="insert-before"><span></span>    <span class="k">if</span> <span class="o">(</span><span class="n">stmt</span><span class="o">.</span><span class="na">value</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</pre><div class="source-file"><em>lox/Resolver.java</em><br>
in <em>visitReturnStmt</em>()</div>
<pre class="insert"><span></span>      <span class="k">if</span> <span class="o">(</span><span class="n">currentFunction</span> <span class="o">==</span> <span class="n">FunctionType</span><span class="o">.</span><span class="na">INITIALIZER</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Lox</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="n">stmt</span><span class="o">.</span><span class="na">keyword</span><span class="o">,</span>
            <span class="s">&quot;Cannot return a value from an initializer.&quot;</span><span class="o">);</span>
      <span class="o">}</span>
<br></pre><pre class="insert-after"><span></span>      <span class="n">resolve</span><span class="o">(</span><span class="n">stmt</span><span class="o">.</span><span class="na">value</span><span class="o">);</span>
</pre></div>

<p>Phew! That was a whole list of task but our reward is that our little
interpreter has grown an entire programming paradigm. Classes, methods, fields,
<code>this</code>, and constructors. Our baby language is looking awfully grown-up.</p>
<hr />
<div class="challenges">
<h2><a href="#challenges" name="challenges">Challenges</a></h2>

<ol>
<li>
<p>We have methods on instances, but there is no way to define &ldquo;static&rdquo; methods
    that can be called directly on the class object itself. Add support for
    &ldquo;class methods&rdquo; defined inside a class body using a preceding <code>class</code>
    keyword, like so:</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="vg">Math</span> <span class="p">{</span>
  <span class="k">class</span> <span class="n">square</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">n</span> <span class="o">*</span> <span class="n">n</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">print</span> <span class="vg">Math</span><span class="p">.</span><span class="n">square</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span> <span class="c1">// Prints &quot;9&quot;.</span>
</pre></div>


<p>You can solve this however you like, but the &ldquo;metaclasses&rdquo; used by Smalltalk
and Ruby are an elegant approach. <em>Hint: Make LoxClass extend LoxInstance
and go from there.</em></p>
</li>
<li>
<p>Most modern languages support &ldquo;getters&rdquo; and &ldquo;setters&rdquo;&#8202;&mdash;&#8202;members on a class
    that look like field reads and writes but that actually execute user-defined
    code. Extend Lox to support getter methods. These are declared without a
    parameter list. The body of the getter is executed when a property with that
    name is accessed:</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="vg">Circle</span> <span class="p">{</span>
  <span class="n">init</span><span class="p">(</span><span class="n">radius</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">this</span><span class="p">.</span><span class="n">radius</span> <span class="o">=</span> <span class="n">radius</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">area</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mf">3.141592653</span> <span class="o">*</span> <span class="nb">this</span><span class="p">.</span><span class="n">radius</span> <span class="o">*</span> <span class="nb">this</span><span class="p">.</span><span class="n">radius</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">var</span> <span class="n">circle</span> <span class="o">=</span> <span class="vg">Circle</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
<span class="k">print</span> <span class="n">circle</span><span class="p">.</span><span class="n">area</span><span class="p">;</span> <span class="c1">// Prints roughly &quot;50.2655&quot;.</span>
</pre></div>


</li>
<li>
<p>Python and JavaScript allow you to freely access an object&rsquo;s fields from
    outside of its own methods. Ruby and Smalltalk encapsulate instance state.
    Only methods on the class can access the raw fields, and it is up to the
    class to decide which state is exposed. Most statically typed languages
    offer modifiers like <code>private</code> and <code>public</code> to control which parts of a
    class are externally accessible on a per-member basis.</p>
<p>What are the trade-offs between these approaches and why might a language
might prefer one or the other?</p>
</li>
</ol>
</div>
<div class="design-note">
<h2><a href="#design-note" name="design-note">Design Note: Prototypes and Power
</a></h2>

<p>In this chapter, we introduced two new runtime entities, LoxClass and
LoxInstance. The former is where behavior for objects lives and the latter is
for state. What if you could define methods right on a single object inside
LoxInstance? In that case, we wouldn&rsquo;t need LoxClass at all. LoxInstance would
be a complete package for defining the behavior and state of an object.</p>
<p>We&rsquo;d still want some way to reuse behavior across multiple instances. Since
there are no classes, we&rsquo;ll let a LoxInstance delegate directly to another
LoxInstance to reuse its fields and methods, sort of like inheritance. The end
result is a simpler runtime with only a single internal construct, LoxInstance.</p>
<p>Users would model their program as a constellation of objects, some of which
delegate to each other to reflect commonality. There are no longer classes.
Instead, individual objects that are delegated to represent &ldquo;canonical&rdquo; or
&ldquo;prototypical&rdquo; objects that many others are similar to.</p>
<p>That&rsquo;s where the name &ldquo;<a href="https://en.wikipedia.org/wiki/Prototype-based_programming">prototypes</a>&rdquo; comes from for this paradigm. It was
invented by David Ungar and Randall Smith in a language called <a href="http://www.selflanguage.org/">Self</a>. They
came up with it by starting with Smalltalk and following the above mental
exercise to see how much they could simplify it.</p>
<p>Prototypes were an academic curiosity for a long time, a fascinating one that
generated interesting research but didn&rsquo;t make a dent in the larger world of
programming. That is until Brendan took crammed prototypes into JavaScript which
then promptly took over the world. Many (many) <span name="words">words</span>
have been written about prototypes in JavaScript. Whether that shows that
prototypes are brilliant or confusing&#8202;&mdash;&#8202;or both!&#8202;&mdash;&#8202;is an open question.</p>
<aside name="words">
<p>Including <a href="http://gameprogrammingpatterns.com/prototype.html">more than a handful</a> by yours truly.</p>
</aside>
<p>I won&rsquo;t get into whether or not I think prototypes are a good idea for a
language. I&rsquo;ve made languages that are <a href="http://finch.stuffwithstuff.com/">prototypal</a> and
<a href="http://wren.io/">class-based</a>, and my opinions of both are complex. What I want to discuss
is the role of <em>simplicity</em> in a language.</p>
<p>Prototypes are simpler than classes&#8202;&mdash;&#8202;less code for the language implementer to
write, and fewer concepts for the user to learn and understand. Does that make
them better? We language nerds have a tendency to fetishize simplicity.
Personally, I think simplicity is only part of the equation. What we really to
give the user is <em>power</em>, which I define as:</p>
<div class="codehilite"><pre><span></span>power = breadth × ease ÷ complexity
</pre></div>


<p>None of these are precise numeric measures. I&rsquo;m using math as analogy here, not
actual quantification.</p>
<ul>
<li>
<p><strong>Breadth</strong> is the range of different things the language lets you express.
    C has a lot of breadth&#8202;&mdash;&#8202;it&rsquo;s been used for everything from operating
    systems to user applications to games. Domain-specific languages like
    AppleScript and Matlab have less breadth.</p>
</li>
<li>
<p><strong>Ease</strong> is how little effort it takes to make the language do what you
    want. &ldquo;Usability&rdquo; might be another term, though it carries more baggage than
    I want to bring in. &ldquo;Higher-level&rdquo; languages tend to have more ease than
    lower-level ones. Most languages have a &ldquo;grain&rdquo; to them where some things
    feel easier to express than others.</p>
</li>
<li>
<p><strong>Complexity</strong> is how big and complex the language is (and its runtime, core
    libraries, tools, and ecosystem, etc.). People talk about how many pages are
    in a language&rsquo;s spec, or how many keywords it has. It&rsquo;s how much the user
    has to load into their wetware before they can be productive in the system.
    It is the antonym to simplicity.</p>
</li>
</ul>
<p>Reducing complexity <em>does</em> increase power. The smaller the denominator, the
larger the resulting value, so our intuition that simplicity is good is valid.
However, when reducing complexity, we must take care not to sacrifice breadth or
ease in the process, or the total power may go down. Java would be a strictly
<em>simpler</em> language if it removed strings, but it probably wouldn&rsquo;t handle text
manipulation tasks well, nor would it be as easy to get things done.</p>
<p>The art, then is finding <em>accidental</em> complexity that can be omitted. Language
features and interactions that don&rsquo;t carry their weight by increasing the
breadth or ease of using the language.</p>
<p>If users want to express their program in terms of catergories of objects, then
baking classes into the language increases the ease of doing that, hopefully by
a large enough margin to pay for the added complexity. But if that isn&rsquo;t how
users are using your language, then by all means leave classes out.</p>
</div>

<footer>
<a href="inheritance.html" class="next">
  Next Chapter: &ldquo;Inheritance&rdquo; &rarr;
</a>
Hand-crafted by Robert Nystrom&ensp;&mdash;&ensp;<a href="https://github.com/munificent/craftinginterpreters/blob/master/LICENSE" target="_blank">&copy; 2015&hairsp;&ndash;&hairsp;2017</a>
</footer>
</article>

</div>
</body>
</html>