<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<title>Introduction &middot; Crafting Interpreters</title>

<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="stylesheet" type="text/css" href="style.css" />
<link href='http://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600' rel='stylesheet' type='text/css'>
<link rel="icon" type="image/png" href="image/favicon.png" />
<script src="jquery-1.10.1.min.js"></script>
<script src="script.js"></script>
</head>
<body id="top">

<!-- <div class="scrim"></div> -->
<nav class="wide">
  <a href="/"><img src="image/logotype-small.png" title="Crafting Interpreters"></a>
  <div class="contents">
<!-- If there is a part, it must be a chapter within a part. -->
<h3><a href="#top"><small>1.</small> Introduction</a></h3>

<ul>
    <li><a href="#why-learn-this-stuff">Why learn this stuff?</a></li>
    <li><a href="#how-the-book-is-organized">How the book is organized</a></li>
    <li><a href="#the-first-interpreter">The first interpreter</a></li>
    <li><a href="#the-second-interpreter">The second interpreter</a></li>
    <li><a href="#challenges">Challenges</a></li>
</ul>


<div class="prev-next">
    <a href="welcome.html" title="Welcome">←&nbsp;Previous</a>
    <a href="a-map-of-the-territory.html" title="A Map of the Territory" class="right">Next&nbsp;→</a>
</div>  </div>
</nav>

<nav class="narrow">
<a href="/"><img src="image/logotype-small.png" title="Crafting Interpreters"></a>
<a href="welcome.html" title="Welcome" class="prev">←</a>
<a href="a-map-of-the-territory.html" title="A Map of the Territory" class="next">→</a>
</nav>

<div class="page">
<div class="nav-wrapper">
<nav class="floating">
  <a href="/"><img src="image/logotype-small.png" title="Crafting Interpreters"></a>
  <div class="expandable">
<!-- If there is a part, it must be a chapter within a part. -->
<h3><a href="#top"><small>1.</small> Introduction</a></h3>

<ul>
    <li><a href="#why-learn-this-stuff">Why learn this stuff?</a></li>
    <li><a href="#how-the-book-is-organized">How the book is organized</a></li>
    <li><a href="#the-first-interpreter">The first interpreter</a></li>
    <li><a href="#the-second-interpreter">The second interpreter</a></li>
    <li><a href="#challenges">Challenges</a></li>
</ul>


<div class="prev-next">
    <a href="welcome.html" title="Welcome">←&nbsp;Previous</a>
    <a href="a-map-of-the-territory.html" title="A Map of the Territory" class="right">Next&nbsp;→</a>
</div>  </div>
  <a id="expand-nav">≡</a>
</nav>
</div>

<article class="chapter">

  <div class="number">1</div>
  <h1>Introduction</h1>

<div class="sign-up">
    <h1>This book is a work in progress!</h1>
  <span class="dismiss">&times;</span>
    <p>If you see a mistake, find something unclear, or have a suggestion, please <a href="https://github.com/munificent/crafting-interpreters/issues" target="_blank">file a ticket</a>. To know when new chapters are up, join the mailing list:</p>

  <!-- Begin MailChimp Signup Form -->
  <div id="mc_embed_signup">
  <form action="//gameprogrammingpatterns.us7.list-manage.com/subscribe/post?u=0952ca43ed2536d6717766b88&amp;id=6e96334109" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate>
    <input type="email" value="" name="EMAIL" class="email" id="mce-EMAIL" placeholder="Your email address" required>
    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->
    <div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_0952ca43ed2536d6717766b88_6e96334109" tabindex="-1" value=""></div>
    <input type="submit" value="Sign me up!" name="subscribe" id="mc-embedded-subscribe" class="button">
  </form>
  </div>
  <!--End mc_embed_signup-->
  <p class="small">(I post about once a month. Don&#8217;t worry, I won&#8217;t spam you.)</p>
</div>

  <blockquote>
<p>No, no! The adventures first, explanations take such a dreadful time.</p>
<p><cite>Lewis Carroll</cite></p>
</blockquote>
<p>I&rsquo;m really excited we&rsquo;re going on this journey together. This is a book on
implementing interpreters for programming languages. It&rsquo;s also a book on how to
design a language worth implementing. It&rsquo;s the book I wished I had when I first
started getting into languages, and it&rsquo;s the book I&rsquo;ve been writing in my <span
name="head">head</span> for nearly a decade.</p>
<aside name="head">
<p>To my friends and family, sorry I&rsquo;ve been so absent-minded!</p>
</aside>
<p>In these pages, we will walk step by step through two complete interpreters for
a full-featured language. I assume this is your first foray into languages, so
I&rsquo;ll cover each concept and line of code you need to build a complete, usable,
fast language implementation.</p>
<p>In order to cram two full implementations inside one book without it turning
into a doorstop, this book is lighter on theory than others. As we build each
piece of the system, I will introduce the history and concepts behind it. I&rsquo;ll
try to get you familiar with the lingo so that if you ever find yourself in a
cocktail <span name="party">party</span> full of PL (programming language)
researchers, you&rsquo;ll fit in.</p>
<aside name="party">
<p>Strangely enough, a situation I have found myself in multiple times. You
wouldn&rsquo;t believe how much some of them can drink.</p>
</aside>
<p>But we&rsquo;re mostly going to spend our brain juice getting our language up and
running. This is not to say theory isn&rsquo;t important. Being able to reason
precisely and <span name="formal">formally</span> about syntax and semantics is
a vital skill when working on a language. But, personally, I learn best by
doing. It&rsquo;s hard for me to wade through paragraphs full of abstract concepts and
really absorb them. But if I&rsquo;ve implemented a concept, debugged it,
ran it, and poked at it, then I <em>get</em> it.</p>
<aside name="formal">
<p>Static type systems in particular require rigorous formal reasoning. Hacking on
a type system has the same feel as proving a theorem in mathematics. It turns
out this is no coincidence. In the early half of last century, Haskell Curry
and William Alvin Howard showed that they are two sides of the same coin: <a href="https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence">the
Curry-Howard isomorphism</a>.</p>
</aside>
<p>That&rsquo;s my goal for you. I want you to come away with a solid intuition of how a
real language lives and breathes. My hope is that you read other, more theoretical books later, they will more easily stick in your mind, adhered to this tangible foundation.</p>
<h2><a href="#why-learn-this-stuff" name="why-learn-this-stuff">Why learn this stuff?</a></h2>
<p>Every introduction to every language book seems to have this section. I don&rsquo;t
know what it is about programming languages that causes this existential doubt.
I don&rsquo;t think ornithology books worry about justifying their existence. They assume the reader loves birds and get moving.</p>
<p>But programming languages are a little different. I suppose it&rsquo;s true that the
odds of any of us creating a broadly successful general purpose programming
language are slim. The designers of the world&rsquo;s widely-used languages could fit
in a Volkswagen bus, even without putting the pop top camper up. If joining that
elite group was the <em>only</em> reason to learn languages, it would be hard to
justify. Fortunately, it isn&rsquo;t.</p>
<h3><a href="#little-languages-are-everywhere" name="little-languages-are-everywhere">Little languages are everywhere</a></h3>
<p>For every successful <em>general purpose</em> language out there, there are a thousand
successful niche ones. We used to call them &ldquo;little languages&rdquo;, but
inflation in the jargon economy lead today to the name &ldquo;domain-specific
languages&rdquo;. These are pidgins tailor-built to a specific task. Things like
application-specific scripting languages, template engines, markup formats, and
configuration files.</p>
<p>Almost every large software project needs a handful of these. When you can, it&rsquo;s
good to reuse an existing one instead of rolling your own. When you take into
account the need for documentation, debuggers, editor support, syntax
highlighting, and all of the other accoutrements, doing it yourself becomes a
tall order.</p>
<p>But there&rsquo;s still a good chance you&rsquo;ll find yourself needing to whip up a parser
or something when there isn&rsquo;t an existing library that fits your needs. Even
when there <em>is</em> one you can reuse, you&rsquo;ll inevitably end up needing to debug and
maintain it and poke around in its guts.</p>
<h3><a href="#languages-are-great-exercise" name="languages-are-great-exercise">Languages are great exercise</a></h3>
<p>Long distance runners sometimes train with weights strapped to their ankles or
at high altitudes where the air is thin. When they later unburden themselves,
the new relative ease of light limbs and oxygen-rich air enables them to run
farther and faster.</p>
<p>Implementing a language is a real test of programming skill. The code is complex
and performance critical. You must master recursion and recursive algorithms.
You need to completely understand dynamic arrays, trees, graphs, and hash
tables.</p>
<p>You probably use stuff like hash tables in your day-to-day programming, but how
well do you <em>really</em> understand them? Well, after we&rsquo;ve crafted our own from
scratch, I promise you will.</p>
<p>While I hope to show you that a programming language isn&rsquo;t as daunting as you
might believe, it is still a challenge. Rise to it, and you&rsquo;ll come away a
stronger programmer, and smarter about how you use data structures and
algorithms in your day job.</p>
<h3><a href="#one-more-reason" name="one-more-reason">One more reason</a></h3>
<p>This last reason it hard for me to admit, because it&rsquo;s close to my heart. Ever
since I learned to program as a kid, I felt there as something magical about
languages. When I first tapped out BASIC programs one key at a time I couldn&rsquo;t
conceive how BASIC <em>itself</em> was made.</p>
<p>Later, the mixture of awe and terror my college friends used to refer to their
compilers class was enough to convince me language hackers were a different
breed of human. Some sort of wizards granted priveleged access to arcane arts.</p>
<p>It&rsquo;s a charming <span name="image">image</span>, but it has a darker side. I
know <em>I&rsquo;m</em> not a wizard, so I was left feeling like I lacked some in-born
quality necessary to join the cabal. Though I&rsquo;ve been fascinated by languages
ever since I doodled made up keywords in my school notebook, it took me decades
to muster the courage to try to really learn them. That &ldquo;magical&rdquo; quality, that
sense of exclusivity, excluded <em>me</em>.</p>
<aside name="image">
<p>And one its practitioners don&rsquo;t hesitate to play up. Two of the seminal texts on
programming languages feature a dragon and a wizard on their cover.</p>
</aside>
<p>When I did finally start cobbling together my own little interpreters, I quickly
learned that, of course, there is no magic at all. It&rsquo;s just code, and the
people who hack on languages are just people.</p>
<p>There <em>are</em> a few techniques you don&rsquo;t often encounter outside of languages, and
some parts are a little difficult. But not more difficult than other obstacles
you&rsquo;ve overcome. My hope is that if you&rsquo;ve felt intimidated by languages, and
this book helps you overcome that fear, maybe I&rsquo;ll leave you just a tiny bit
braver than you were before.</p>
<p>And, who knows, maybe you <em>will</em> make the next great language. Someone has to.</p>
<h2><a href="#how-the-book-is-organized" name="how-the-book-is-organized">How the book is organized</a></h2>
<p>This book is broken into three parts. You&rsquo;re reading the first one now. It&rsquo;s a
couple of chapters to get you oriented, teach you some of the lingo language
hackers use, and introduce you to Lox, the language we&rsquo;ll be implementing.</p>
<p>Each of the other two parts builds one complete Lox interpreter. Within these
parts, each chapter is structured the same. Every one takes a single language feature teaches you the concepts behind it and how to implement it.</p>
<p>It took a good bit of trial and error on my part, but I managed to carve up the
two interpreters into chapter-sized chunks so that each builds on the previous
ones. From the very first chapter, you&rsquo;ll have a program you can run and play
with. With each passing chapter, it grows increasingly full-featured until you
eventually have a complete language.</p>
<p>Aside from copious, scintillating English prose, chapters have a few other delightful facets:</p>
<h3><a href="#the-code" name="the-code">The code</a></h3>
<p>We&rsquo;re about <em>crafting</em> interpreters, so this book contains real code. Every
single line of code needed is included, and each snippet tells you where to
insert it in your ever-growing implementation.</p>
<p>Many other language books and language implementations use tools like <a href="https://en.wikipedia.org/wiki/Lex_(software)">Lex</a>
and <span name="yacc"><a href="https://en.wikipedia.org/wiki/Yacc">Yacc</a></span>, &ldquo;compiler-compilers&rdquo; to automatically
generate some of the source files for an implementation from some higher level
description. There are pros and cons to tools like those, and strong
opinions&#8202;&mdash;&#8202;some might say religious convictions&#8202;&mdash;&#8202;on both sides.</p>
<aside name="yacc">
<p>Yacc is a tool that takes in a grammar file and produces a source file for a
compiler, so it&rsquo;s sort of like a &ldquo;compiler&rdquo; that outputs a compiler. Hence the
name, &ldquo;compiler-compiler&rdquo;.</p>
<p>It wasn&rsquo;t the first of its ilk, which is why it&rsquo;s named &ldquo;Yacc&rdquo;&#8202;&mdash;&#8202;Yet Another
Compiler-Compiler. A later similar tool is <a href="https://en.wikipedia.org/wiki/GNU_bison">Bison</a>, named as a pun on the
pronunciation of Yacc like &ldquo;yak&rdquo;.</p>
<p>If you find all of these little self-references and puns charming and fun,
you&rsquo;ll fit right in here. If not, well, maybe the language nerd sense of humor
is an acquired taste.</p>
</aside>
<p>We will abstain from using them here. I want to ensure there are no dark corners
where magic and confusion can hide, so we&rsquo;ll write everything by hand. As you&rsquo;ll
see, it&rsquo;s not as bad as it sounds and it means you really will understand each
line of code and how both interpreters work.</p>
<p>A book has different constraints from &ldquo;real world&rdquo; code and so the style of the
code here might not always reflect the best way to write maintainable code in a
production codebase. If I seem a little cavalier about, say, omitting <code>private</code>
or declaring a global variable, understand I do so to keep the code easier on
your eyes. The pages here aren&rsquo;t as wide as your IDE and every character counts.</p>
<p>Also, the code here doesn&rsquo;t have many comments. That&rsquo;s because each handful of
lines is surrounded by several paragraphs of honest-to-God prose explaining it.
If you write a book to accompany each of your programs, you are welcome to omit comments too. Otherwise, you should probably use <code>//</code> a little more than I
do.</p>
<p>(What this book <em>doesn&rsquo;t</em> contain is the machinery needed to compile and run the
code. I assume you can slap together a makefile or a project in your IDE of
choice in order to get the code to run.)</p>
<h3><a href="#asides" name="asides">Asides</a></h3>
<p><span name="aside">Asides</span> contain biographical sketches, historical
background, references to related topics, and suggestions of other areas to
explore. There&rsquo;s nothing that you <em>need</em> to know in them to understand later
parts of the book, so you can skip them if you want. I won&rsquo;t judge you, but I
might be a little sad.</p>
<aside name="aside">
<p>Well, some do, at least. Most of them are just dumb jokes and amateurish
drawings. Sorry.</p>
</aside>
<h3><a href="#challenges" name="challenges">Challenges</a></h3>
<p>Each chapter ends with a few exercises. Unlike textbook problem sets which tend
to rehash material you already covered, these are to help you learn <em>more</em> than
what&rsquo;s in the chapter. They force you to step off the guided path and explore on
your own. They will make you research other languages, figure out how to
implement features or otherwise get you to strike out on your own.</p>
<p>Boldly attack them and you&rsquo;ll come away with a broader understanding and
possibly a few bumps and scrapes. Or skip them if you just want to stay inside
the comfy confines of the tour bus. It&rsquo;s your book.</p>
<h3><a href="#design-notes" name="design-notes">Design notes</a></h3>
<p>Most &ldquo;programming language&rdquo; books are strictly programming language
<em>implementation</em> books. They rarely discuss how one might happen to <em>design</em> the
language being implemented. This book is half guilty of that. I already did the
work to design Lox so you don&rsquo;t have to.</p>
<p>Focusing on implementation is fun because it is so <span
name="benchmark">crisply-defined</span>. We programmers seem to have an affinity for things that are black and white. Taking an existing language&rsquo;s test suite and cranking out a new implementation that makes all the tests pass is the ultimate idealized software engineering project, and deeply satisfying. Especially when it runs faster than the previous implementation.</p>
<aside name="benchmark">
<p>I know a lot of language hackers who whose careers are based on this. You slide a language spec under their door, wait a few months, and code and benchmark results come out.</p>
</aside>
<p>I don&rsquo;t know about you, but I think the world only needs so many implementations
of FORTRAN 77. At some point, you end up designing a new language. And once you
start playing <em>that</em> game, then the softer, human side of the equation becomes
paramount. Things like what features are easy to learn, how to balance
innovation and familiarity, which syntaxes are easier to read.</p>
<p>All of that stuff profoundly affects the success of your new language. But most
books don&rsquo;t talk much about it, I think in large because it is fuzzier. Many
<span name="science">computer scientists</span> feel uncomfortable talking about
anything that can&rsquo;t be proven like a theorem.</p>
<aside name="science">
<p>There&rsquo;s an age-old joke that any discipline that feels the need to put &ldquo;science&rdquo; in its name is just a pretender. &ldquo;Chemistry&rdquo;? Real science. &ldquo;Biology&rdquo;? Yup. &ldquo;Polical science&rdquo;? Umm. &ldquo;Computer science&rdquo;? Well, drat.</p>
</aside>
<p>I consider a programming language to be, in large part, a user interface. It is
a tool you use to communicate how a machine should behave to the computer, to
other maintainers of the code, and even yourself. You can&rsquo;t design a good
language if you don&rsquo;t think about the people using it, even though we Homo
sapiens don&rsquo;t have the pleasant crispness of discrete mathematics.</p>
<p>To that end, many chapters also contain a &ldquo;design note&rdquo;. Each is little essay on
some corner of the human aspect of programming languages. I don&rsquo;t claim to be an
expert on any of this&#8202;&mdash;&#8202;I don&rsquo;t know if anyone really can
&ndash; so take these with a large pinch of salt. That should make them tastier food
for thought, which is my main aim. If you come away disagreeing with me on all
accounts, but still <em>caring</em> about the user side of languages, that&rsquo;s enough for
me.</p>
<p>On the other hand, if you just want to pump out some code for an interpreter and
get it running, feel free to skip these sections.</p>
<p>&mdash; to here &mdash;</p>
<h2><a href="#the-first-interpreter" name="the-first-interpreter">The first interpreter</a></h2>
<p>We&rsquo;ll write our first interpreter, jlox, in Java. We&rsquo;ll focus on <em>concepts</em>.
We&rsquo;ll write the simplest, cleanest code we can to correctly implement the
semantics of the language. This will get us comfortable with the basic
techniques and also hone our understanding of exactly how the language is
supposed to behave.</p>
<p>ava is a great language for this. It&rsquo;s high level enough that we don&rsquo;t get
overhwelmed by fiddly implementation details, but it&rsquo;s still pretty explicit.
Unlike scripting languages, there tends to be less magic under the hood, and
you&rsquo;ve got static types to see exactly what kinds of objects you&rsquo;re working
with.</p>
<p>I also chose it specifically because it is an <em>object-oriented</em> language. That
paradigm swept the programming world in the 90s and is now the dominant way of
thinking for millions of programmers. Odds are good you&rsquo;re already used to
organizing things into classes and methods, so we&rsquo;ll keep you in that comfort
zone.</p>
<p>While academic language folks sometimes look down on object-oriented languages,
the reality is that they are widely used even for language work today as well.
GCC and LLVM are written in C++, as are most JavaScript virtual machines. Object
oriented languages are ubiquitous and the tools and compilers <em>for</em> a language
are often written <em>in</em> the <span name="host">same language</span>.</p>
<aside name="host">
<p>A compiler is a program that reads in files in one language and translates them
to files in another language. You can implement one in any language, including
the same language it uses for its input, a process called <strong>&ldquo;self-hosting&rdquo;.</strong></p>
<p>Of course, you can&rsquo;t compiler your compiler using your compiler if you&rsquo;ve never
compiled it. So, first, you need an existing compiler for your language that&rsquo;s
written in some other language you <em>can</em> compile already. But once you&rsquo;ve used
that other compiler once, you now have a compiled version of your compiler that
was produced by itself. Now you can throw away the version you compiled with the
other compiler.</p>
<p>Henceforth, you can keep using previous versions of your own compiler to compile
the next version of it. This is called <strong>&ldquo;bootstrapping&rdquo;</strong> from the image of
pulling yourself up by your own bootstraps. (This is also where we get the term
<strong>&ldquo;booting&rdquo;</strong> for starting up a computer.)</p>
<p><strong>TODO: Illustration.</strong></p>
<p>A language ecosystem needs lots of different tools beyond just the core
compiler. You&rsquo;ll need editors, debuggers, formatters, etc. Most language
designers prefer to write those tools in their own language so they can get some
first-hand experience with their language, and so they aren&rsquo;t as dependent on
other languages. They call this &ldquo;eating your own dogfood&rdquo; or just
<strong>&ldquo;dogfooding&rdquo;</strong>.</p>
</aside>
<p>And, finally, Java is hugely popular. That means there&rsquo;s a good chance you
already know it, so there&rsquo;s less for you to learn to get going in the book. If
you aren&rsquo;t that familiar with Java, don&rsquo;t freak out. I try to stick to a fairly
minimal subset of it. I use the diamond operator from Java 7 to makes things a
little more terse, but that&rsquo;s about it as far as &ldquo;advanced&rdquo; features go. If you
know another object-oriented language like C# or C++, you can probably muddle
through fine.</p>
<p>By the end of part II, we&rsquo;ll have a simple, readable implementation. What we
won&rsquo;t have is a <em>fast</em> one. It also leans on Java for managing memory and
representing objects. But we want to learn how the Java virtual machine <em>itself</em>
implements those things.</p>
<h2><a href="#the-second-interpreter" name="the-second-interpreter">The second interpreter</a></h2>
<p>So in the next part, we&rsquo;ll start all over again, but this time in C. C is the
perfect language for understanding how an implementation <em>really</em> works, all the
way down to the bytes in memory and the code flowing through the CPU. It makes
explicit the few things Java doesn&rsquo;t: how memory is managed, and how objects are
represented.</p>
<p>A big reason that we&rsquo;re using C is so I can show you things C is particularly
good at, but that <em>does</em> mean you&rsquo;ll need to be pretty handy with it. You don&rsquo;t
have to be the reincarnation of Dennis Ritchie, but you shouldn&rsquo;t be spooked by
pointers either.</p>
<p>If you aren&rsquo;t there yet, pick up an introductory book on C and chew through it,
then come back here when you&rsquo;re done. In return, you&rsquo;ll come away from this book
an even stronger C programmer. That&rsquo;s useful given how many language
implementations are written in C: Lua, CPython, and Ruby&rsquo;s MRI, to name a few.</p>
<p>Our C interpreter, <span name="clox">clox</span>, forces us to implement
ourselves all the things Java gave us for free. We&rsquo;ll write our own dynamic
array and hash table. We&rsquo;ll decide how objects are represented in memory, and
build a garbage collector to reclaim it.</p>
<aside name="clox">
<p>I pronounce the name like &ldquo;sea-locks&rdquo;, but you can say it &ldquo;clocks&rdquo; or even
&ldquo;clochs&rdquo;, where you pronounce the &ldquo;x&rdquo; like the Greeks do if it makes you happy.</p>
</aside>
<p>Our Java implementation was focused on being correct. Now that we have that
down, we&rsquo;ll turn to also being <em>fast</em>. Our C interpreter will contain a <span
name="compiler">compiler</span> that translates the code to an efficient
bytecode representation (don&rsquo;t worry, I&rsquo;ll get into what that means soon) which
it then executes. This is the same technique used by implementations of Lua,
Python, Ruby, PHP and many other successful languages.</p>
<aside name="compiler">
<p>Did you think this was just an interpreters book? It&rsquo;s a compiler book as well.
Two for the price of one!</p>
</aside>
<p>We&rsquo;ll even try our hand at benchmarking and optimization. By the end we&rsquo;ll have
a robust, accurate, fast interpreter for our language, able to keep up with
other professional caliber language implementations out there. Not bad for one
book and a few thousand lines of code.</p>
<div class="challenges">
<h2><a href="#challenges" name="challenges">Challenges</a></h2>
<ol>
<li>
<p>There are least six domain-specific languages used in the <a href="https://github.com/munificent/crafting-interpreters">little system I
   cobbled together</a> to write and publish this book. What are they?</p>
</li>
<li>
<p>Get a &ldquo;Hello, world!&rdquo; program written and running in Java. Set up whatever
   Makefiles or IDE projects you need to get it working. If you have a debugger,
   get comfortable with it and step through your program as it runs.</p>
</li>
<li>
<p>Do the same thing for C. To get some practice with pointers, define a
   <a href="https://en.wikipedia.org/wiki/Doubly_linked_list">doubly-linked list</a> of heap-allocated strings. Write functions to insert,
   find, and delete items from it. Test them.</p>
</li>
</ol>
</div>

<footer>&copy; 2016 Robert Nystrom</footer>
</article>

</div>
</body>
</html>