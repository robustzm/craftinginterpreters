<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<title>Resolving and Binding &middot; Crafting Interpreters</title>

<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="stylesheet" type="text/css" href="style.css" />

<!-- Oh, God, Source Code Pro is so beautiful it makes me want to cry. -->
<link href='http://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600' rel='stylesheet' type='text/css'>
<link rel="icon" type="image/png" href="image/favicon.png" />
<script src="jquery-1.10.1.min.js"></script>
<script src="script.js"></script>

<!-- Google analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42804721-2', 'auto');
  ga('send', 'pageview');
</script>

</head>
<body id="top">

<!-- <div class="scrim"></div> -->
<nav class="wide">
  <a href="/"><img src="image/logotype-small.png" title="Crafting Interpreters"></a>
  <div class="contents">
<!-- If there is a part, it must be a chapter within a part. -->
<h3><a href="#top">Resolving and Binding<small>11</small></a></h3>

<ul>
    <li><a href="#static-scope"><small>11.1</small> Static Scope</a></li>
    <li><a href="#resolution"><small>11.2</small> Resolution</a></li>
    <li><a href="#a-resolver-class"><small>11.3</small> A Resolver Class</a></li>
    <li><a href="#interpreting-resolved-variables"><small>11.4</small> Interpreting Resolved Variables</a></li>
    <li><a href="#running-the-resolver"><small>11.5</small> Running the Resolver</a></li>
</ul>


<div class="prev-next">
    <a href="functions.html" title="Functions" class="left">&larr;&nbsp;Previous</a>
    <a href="a-tree-walk-interpreter.html" title="A Tree-Walk Interpreter">&uarr;&nbsp;Up</a>
    <a href="classes.html" title="Classes" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
</nav>

<nav class="narrow">
<a href="/"><img src="image/logotype-small.png" title="Crafting Interpreters"></a>
<a href="functions.html" title="Functions" class="prev">←</a>
<a href="classes.html" title="Classes" class="next">→</a>
</nav>

<div class="page">
<div class="nav-wrapper">
<nav class="floating">
  <a href="/"><img src="image/logotype-small.png" title="Crafting Interpreters"></a>
  <div class="expandable">
<!-- If there is a part, it must be a chapter within a part. -->
<h3><a href="#top">Resolving and Binding<small>11</small></a></h3>

<ul>
    <li><a href="#static-scope"><small>11.1</small> Static Scope</a></li>
    <li><a href="#resolution"><small>11.2</small> Resolution</a></li>
    <li><a href="#a-resolver-class"><small>11.3</small> A Resolver Class</a></li>
    <li><a href="#interpreting-resolved-variables"><small>11.4</small> Interpreting Resolved Variables</a></li>
    <li><a href="#running-the-resolver"><small>11.5</small> Running the Resolver</a></li>
</ul>


<div class="prev-next">
    <a href="functions.html" title="Functions" class="left">&larr;&nbsp;Previous</a>
    <a href="a-tree-walk-interpreter.html" title="A Tree-Walk Interpreter">&uarr;&nbsp;Up</a>
    <a href="classes.html" title="Classes" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
  <a id="expand-nav">≡</a>
</nav>
</div>

<article class="chapter">

  <div class="number">11</div>
  <h1>Resolving and Binding</h1>

<div class="sign-up closable">
    <h1>This book is a work in progress!</h1>
    <span class="dismiss">&times;</span>
    <p>If you see a mistake, find something unclear, or have a suggestion, please <a href="https://github.com/munificent/craftinginterpreters/issues" target="_blank">let me know</a>. To learn when new chapters are up, join the mailing list:</p>

  <!-- Begin MailChimp Signup Form -->
  <div id="mc_embed_signup">
  <form action="//gameprogrammingpatterns.us7.list-manage.com/subscribe/post?u=0952ca43ed2536d6717766b88&amp;id=6e96334109" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate>
    <input type="email" value="" name="EMAIL" class="email" id="mce-EMAIL" placeholder="Your email address" required>
    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->
    <div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_0952ca43ed2536d6717766b88_6e96334109" tabindex="-1" value=""></div>
    <input type="submit" value="Sign me up!" name="subscribe" id="mc-embedded-subscribe" class="button">
  </form>
  </div>
  <!--End mc_embed_signup-->
  <p class="small">(I post about once a month. Don&#8217;t worry, I won&#8217;t spam you.)</p>
</div>

<blockquote>
<p>Once in a while you find yourself in an odd situation. You get into it by
degrees and in the most natural way but, when you are right in the midst of
it, you are suddenly astonished and ask yourself how in the world it all came
about.</p>
<p><cite>Thor Heyerdahl</cite></p>
</blockquote>
<p>Way back when we <a href="statements-and-state.html">added variables and block scope</a> to Lox, we got
the scoping rules right then. But when we <a href="functions.html">later added functions</a>
and, in particular, closures, we inadvertantly poked a hole in our formerly
watertight lexical scoping implementation. In practice, most programs are
unlikely to stumble into this hole, but as language implementers, we take a
sacred vow to care about correctness even in the most obscure dark corners of
the semantics.</p>
<p>So we will spend this entire chapter plumbing the depths of that hole, and then
carefully, thoroughly, patching it up. In the process, we will gain a more
rigorous understanding of lexical scoping as used by Lox and other languages in
the C tradition. We&rsquo;ll also get a chance to learn about <em>static analysis</em>&#8202;&mdash;&#8202;a
useful technique for writing tools that extract meaning from the user&rsquo;s source
code.</p>
<h2><a href="#static-scope" name="static-scope"><small>11&#8202;.&#8202;1</small> Static Scope</a></h2>
<p>When we introduced variables, we talked about how Lox, like most modern
languages, uses <em>lexical</em> scoping. This means that when you&rsquo;re sitting there
looking at a variable usage, you (and an implementation) can figure out which
declaration that variable refers to just be reading the text of the program. For
example:</p>
<div class="codehilite"><pre><span></span><span class="k">var</span> <span class="n">a</span> <span class="o">=</span> <span class="s">&quot;outer&quot;</span><span class="p">;</span>
<span class="p">{</span>
  <span class="k">var</span> <span class="n">a</span> <span class="o">=</span> <span class="s">&quot;inner&quot;</span><span class="p">;</span>
  <span class="n">print</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>Here, we can figure out that the <code>a</code> being printed is the variable declared on
the previous line, and not the one declared globally. The dynamic execution of
the program doesn&rsquo;t affect this. In other words, the scope rules are part of the
<em>static</em> semantics of the language and Lox features <strong>static scope</strong>.</p>
<p>I&rsquo;ve never really spelled out what these static scoping rules are. They are
similar to languages you are familiar with like C and Java, so I assumed you had
the right idea already. Now is a good time to be a <span name="precise">little
more precise</span>.</p>
<aside name="precise">
<p>This is still nowhere near as precise as a real language specification should
be. I&rsquo;m aiming for just good enough for you and I to have the same idea in mind.
A real language spec intends to be so unambiguous that even a Martian our an
outright malicious implementer would still be forced to implement the correct
semantics as long as they followed the letter of the spec.</p>
<p>That level of clarity is important when a language may be implemented by
multiple competing companies who have an incentive to have their implementations
be incompatible with each other to lock customers into their own
implementations. For this book, we don&rsquo;t need to worry about that level of
malice.</p>
<p><strong>todo: malice synonym.</strong></p>
</aside>
<p><strong>A use of a variable refers to the preceding variable declaration of the same
name in the innermost scope that encloses the expression where the variable is
used.</strong></p>
<p>There&rsquo;s a lot to unpack in that:</p>
<ul>
<li>
<p>I say &ldquo;use of a variable&rdquo; instead of &ldquo;variable expression&rdquo; to cover both
    variable expressions and assignments. Likewise &ldquo;expression where the
    variable is used&rdquo;.</p>
</li>
<li>
<p>&ldquo;Preceding&rdquo; means appearing before in the program text. Given:</p>
<div class="codehilite"><pre><span></span><span class="k">var</span> <span class="n">a</span> <span class="o">=</span> <span class="s">&quot;outer&quot;</span><span class="p">;</span>
<span class="p">{</span>
  <span class="n">print</span> <span class="n">a</span><span class="p">;</span>
  <span class="k">var</span> <span class="n">a</span> <span class="o">=</span> <span class="s">&quot;inner&quot;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>Here, the <code>a</code> bring printed is the outer one since it appears <span
name="hoisting">before</span> the print statement that uses it. In most
cases, in straight line code, the declaration preceding in <em>text</em> will also
precede the usage in <em>time</em>.</p>
<aside markdown="1" name="hoisting">

<p>JavaScript does not always follow this rule. In JavaScript, variables
declared anywhere in a block are implicitly &ldquo;hoisted&rdquo; to the beginning of
the block. That means any of use a variable with the same name in the block
will refer to that variable, even if the use appears before the declaration.
When you write this in JavaScript:</p>
<div class="codehilite"><pre><span></span><span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span>
  <span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="s2">&quot;value&quot;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>It implicitly treated like:</p>
<div class="codehilite"><pre><span></span><span class="p">{</span>
  <span class="kd">var</span> <span class="nx">a</span><span class="p">;</span> <span class="c1">// Hoist.</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span>
  <span class="nx">a</span> <span class="o">=</span> <span class="s2">&quot;value&quot;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>Note that it means that in some cases, you can access a variable before its
initializer has run, an annoying source of bugs in JavaScript.</p>
</aside>

<p>But that&rsquo;s not <em>always</em> true. Consider:</p>
<div class="codehilite"><pre><span></span><span class="k">var</span> <span class="n">a</span> <span class="o">=</span> <span class="s">&quot;outer&quot;</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="k">var</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="n">print</span> <span class="n">a</span><span class="p">;</span>
  <span class="k">var</span> <span class="n">a</span> <span class="o">=</span> <span class="s">&quot;inner&quot;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>Here, the second inner declaration of <code>a</code> will execute before the access of
<code>a</code> in the print does. Even though the second declaration executes first in
time, it does not <em>precede</em> the access in the print statement. This
distinction is important because it what seperates the static textual
ordering of the code from the dynamic temporal execution.</p>
</li>
<li>
<p>&ldquo;Innermost&rdquo; is there because of our good friend shadowing. There may be more
    than one variable with the given name in enclosing scopes, as in:</p>
<div class="codehilite"><pre><span></span><span class="k">var</span> <span class="n">a</span> <span class="o">=</span> <span class="s">&quot;outer&quot;</span><span class="p">;</span>
<span class="p">{</span>
  <span class="k">var</span> <span class="n">a</span> <span class="o">=</span> <span class="s">&quot;inner&quot;</span><span class="p">;</span>
  <span class="n">print</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>Our rule disambiguates this case by saying the innermost scope wins.</p>
</li>
</ul>
<p>This dense rule, once you unfurl it, implies that a variable expression always
refers to the same declaration through the entire execution of the program.
That&rsquo;s why it&rsquo;s called <em>static</em> scope.</p>
<p>Our interpreter so far mostly implements the above rule correctly. But when we
added closures, we let an error slip in:</p>
<div class="codehilite"><pre><span></span><span class="k">var</span> <span class="n">a</span> <span class="o">=</span> <span class="s">&quot;global&quot;</span><span class="p">;</span>
<span class="p">{</span>
  <span class="k">fun</span> <span class="n">showA</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">print</span> <span class="n">a</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">showA</span><span class="p">();</span>
  <span class="k">var</span> <span class="n">a</span> <span class="o">=</span> <span class="s">&quot;block&quot;</span><span class="p">;</span>
  <span class="n">showA</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>


<p>Before you type this in and run it, decide what you think it <em>should</em> print.
If you&rsquo;re familiar with closures in other languages, you expect it to print
&ldquo;global&rdquo; twice. The first call to <code>showA()</code> should definitely print &ldquo;global&rdquo;
since we haven&rsquo;t even reached the declaration if the inner <code>a</code> yet. And by our
implied rule that a variable expression always resolves to the same variable,
that means the second call to <code>showA()</code> should print the same thing.</p>
<p>Now try it out. Alas, it prints:</p>
<div class="codehilite"><pre><span></span>global
block
</pre></div>


<p>I want to stress that this program never reassigns any existing variable and
only contains a single print statement. Yet somehow, that print statement for a
never-assigned variable prints two different values at different points in time.
Oops.</p>
<h3><a href="#scopes-and-mutable-environments" name="scopes-and-mutable-environments"><small>11&#8202;.&#8202;1&#8202;.&#8202;1</small> Scopes and mutable environments</a></h3>
<p>In our interpreter, environments are the dynamic sister the static notion of
scopes. The two mostly stay in sync with each other&#8202;&mdash;&#8202;we create a new
environment when we enter a new scope, and discard it when we leave the scope.
There is one other operation we perform on environments: declaring a variable in
one. This is where our bug lies.</p>
<p>Let&rsquo;s walk through that problematic example and see what the environments look
like at each step.</p>
<p><strong>todo: illustrate and explain</strong></p>
<ul>
<li>first just have env for global scope</li>
<li>enter block and create child env</li>
<li>declare showA() in that env</li>
<li>closure captures block</li>
<li>call showA</li>
<li>create new env for activation with parent as closure</li>
<li>look up a, find in global</li>
<li>declare a in block scope</li>
<li>call showA again</li>
<li>create new env for activation with parent as closure</li>
<li>look up a, find in block</li>
</ul>
<p>When we implemented environments, we chose a representation that agrees with our
informal intuition. We tend to think of all code within the same block as being
within the same scope, so our interpreter uses a single environment to represent
that. Each environment is a mutable hash table. When a new variable is declared,
it gets added to the existing environment.</p>
<p>This clashes with how we implement closures. When a function is declared, it
captures a reference to the current environment. The function <em>should</em> be
capturing a frozen snapshot of the environment as it exists at the point that
the function is declared.</p>
<p>But, instead, in the Java code, it has a reference to the actual mutable
Environment object. If a variable is later declared in the scope that
environment corresponds to, the closure will see the new variable, even though
the declaration does <em>not</em> precede the function.</p>
<p>A closure can end up &ldquo;seeing&rdquo; local variables that are declared after the
function.</p>
<h3><a href="#persistent-environments" name="persistent-environments"><small>11&#8202;.&#8202;1&#8202;.&#8202;2</small> Persistent environments</a></h3>
<p>Maybe it&rsquo;s our intuition that&rsquo;s wrong. A block is <em>not</em> all actually the same
scope. If you define &ldquo;scope&rdquo; to mean &ldquo;a set of declarations&rdquo;, it&rsquo;s clear that
these two points in the program aren&rsquo;t in the same scope:</p>
<div class="codehilite"><pre><span></span><span class="p">{</span>
  <span class="k">var</span> <span class="n">a</span><span class="p">;</span>
  <span class="c1">// 1.</span>
  <span class="k">var</span> <span class="n">b</span><span class="p">;</span>
  <span class="c1">// 2.</span>
<span class="p">}</span>
</pre></div>


<p>At the first marked line, only <code>a</code> is in scope. At the second line, both <code>a</code> and
<code>b</code> are. It&rsquo;s as if each variable declaration <span name="split">splits</span>
the block into two separate scopes, the scope before the variable is declared
and the one after, which includes the new variable.</p>
<aside name="split">
<p>Some languages make this split explicit. In Scheme and ML, when you declare a
local variable using <code>let</code>, you also delineate the subsequent code where the new
variable is in scope. There is no implicit &ldquo;rest of the block&rdquo;.</p>
</aside>
<p>There is a style of programming that uses what are called <strong>&ldquo;persistent data
structures&rdquo;</strong>. Unlike the normal mutable data structures you&rsquo;re familiar with in
imperative programming, a persistent data structure can never be directly
modified. Instead, any &ldquo;modification&rdquo; to an existing structure produces a <span
name="copy">brand</span> new structure that contains all of the original data
and the new modification. The original is left unchanged.</p>
<aside name="copy">
<p>This sounds like it might waste tons of memory and time copying the structure
each time. In practice, persistent data structures share most of their data
between the different &ldquo;copies&rdquo;.</p>
</aside>
<p>If we were to apply that technique to Environment, then every time you declared a variable it would return a <em>new</em> environment that contained all of the previously-declared variables along with the one new variable.</p>
<p><strong>todo: illustrate</strong></p>
<p>Since every declaration produces a new Environment object, it means each
environment only ever contains a single declaration. Instead of a HashMap of
variables, all Environment would need is a single one. Something like:</p>
<div class="codehilite"><pre><span></span><span class="kd">class</span> <span class="nc">Environment</span> <span class="o">{</span>
  <span class="kd">final</span> <span class="n">Environment</span> <span class="n">previous</span><span class="o">;</span>
  <span class="kd">final</span> <span class="n">String</span> <span class="n">variable</span><span class="o">;</span>
  <span class="kd">final</span> <span class="n">Object</span> <span class="n">value</span><span class="o">;</span>

  <span class="kd">private</span> <span class="nf">Environment</span><span class="o">(</span>
      <span class="n">Environment</span> <span class="n">previous</span><span class="o">,</span> <span class="n">String</span> <span class="n">variable</span><span class="o">,</span> <span class="n">Object</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">previous</span> <span class="o">=</span> <span class="n">previous</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="n">Environment</span> <span class="nf">define</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">,</span> <span class="n">Object</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">Environment</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">name</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>


<p>Instead of a chain of environments with maps for each <em>scope</em>, you get a linear
chain of environments for each <em>variable</em>. Something like:</p>
<p><strong>todo: illustrate</strong></p>
<p>We&rsquo;d actually need two environment classes, and a common interface, since the
global environment does contain a single mutable map of variables. Global
variables <em>are</em> dynamically resolved, by design, to play nicer with the REPL.
Buy you get the idea.</p>
<p>This doesn&rsquo;t look like it buys us much. But consider how closures work now. A
closure retains a reference to the environment that was current when the
function was declared. Any variables declared after that point don&rsquo;t modify that
environment. Instead, they produce new ones, which the closure won&rsquo;t see. Our
bug would be fixed.</p>
<p>This is one viable way to solve the problem, and it&rsquo;s the classic way to
implement environments in Scheme interpreters. We could do that for Lox, but it
would mean going back and changing a lot of existing code.</p>
<p>Instead, we&rsquo;ll keep the way we represent environments, and change the way we
access variables. Instead of making the data structure persistent and static,
we&rsquo;ll bake the static resolution into the access operation itself.</p>
<h2><a href="#resolution" name="resolution"><small>11&#8202;.&#8202;2</small> Resolution</a></h2>
<p>Our interpreter resolves a variable&#8202;&mdash;&#8202;tracks down which declaration it refers
to&#8202;&mdash;&#8202;each time the variable expression is evaluated. Even if the variable is
used inside a loop that runs a thousand times, it gets re-resolved a thousand
times.</p>
<p>Static scope means that that variable should always resolve to the same
declaration, which can be determined just by looking at the text. Given that,
why are we doing it dynamically every time? Doing so doesn&rsquo;t just open the hole
that leads to our annoying bug, it&rsquo;s also needlessly slow.</p>
<p>A better solution would be to resolve each variable access <em>once</em>. We&rsquo;ll store
that resolution in some way and then the interpreter can reuse it each time it
executes the expression that uses the variable.</p>
<p>There are a lot of ways we could represent the binding between a variable and
its declaration. We could redo our entire Environment class. When we get to the
C interpreter for Lox, we&rsquo;ll have a <em>much</em> more efficient way of storing and
accessing variables.</p>
<p>For now, though, I&rsquo;d like to minimize the amount of collatoral damage we need to
inflict on our existing codebase. I&rsquo;d hate to make you throw out a bunch of
mostly-fine code. Instead, we&rsquo;ll represent the resolution in a way that makes
the most out of our existing Environment structure.</p>
<p>Recall how the accesses of <code>a</code> are interpreted in the problematic example.</p>
<p><strong>todo: illustrate</strong></p>
<p>In the first (correct) evaluation, we walk up three environments in the chain
before finding the global declaration of <code>a</code>. Then, when the inner <code>a</code> is later
declared in an inner scope, it shadows the global one. The next look up walks
the chain only two hops and stops there.</p>
<p><strong>todo: are the numbers right here?</strong></p>
<p>If we could ensure a variable access always walked the <em>same</em> number of levels
in the environment chain, that would prevent the resolved variable from changing
over time. Since each environment corresponds to a single lexical scope, we&rsquo;d
ensure that we are looking up the same variable every time.</p>
<p>To &ldquo;resolve&rdquo; a variable usage, we only need to calculate how many &ldquo;hops&rdquo; away
the declared variable will be in the environment chain. We can do that once,
since it&rsquo;s a static property of the variable and doesn&rsquo;t rely on dynamic
execution.</p>
<p>We can&rsquo;t calculate the actual Environment <em>object</em> where the variable can be
found ahead of time. Remember that we create new environments dynamically each
time a function is called so that recursion works. Instead, we&rsquo;ll determine just
the relative distance from the current environment to the enclosing one where
the variable can be found. Even when the environment objects themselves are
created dynamically, the length of the chain itself always matches the source
text.</p>
<p><strong>todo: illustrate</strong></p>
<p>The interesting question is <em>when</em> to do this calculation&#8202;&mdash;&#8202;or, put
differently, where in our interpreter&rsquo;s implementation do we put the code for
it? Since this is a static property that we can calculate based on the structure
of the source code, the obvious answer is in the parser. This is the traditional
approach, and is what we&rsquo;ll do later in clox.</p>
<p>It would work here too, but I want an excuse to show you another technique.
We&rsquo;ll write our resolver as a separate pass.</p>
<h3><a href="#a-static-analysis-pass" name="a-static-analysis-pass"><small>11&#8202;.&#8202;2&#8202;.&#8202;1</small> A static analysis pass</a></h3>
<p>After the parser produces the syntax tree, but before the interpreter starts
executing it, we&rsquo;ll do a single traversal of the entire tree to resolve all of
the variable. Doing a separate static pass like this after parsing is a
generally handy technique.</p>
<p>If Lox had static types, that&rsquo;s how we&rsquo;d implement the type checker. It would
would the trees calculating the static type of each expression and making sure
they lined up with the expected types where the expressions are used. <span
name="constant">Optimizations</span> are often implemented in separate passes
like this too. Basically, any work that doesn&rsquo;t rely on state that&rsquo;s only
available at runtime can be done in this way.</p>
<aside name="constant">
<p>A simple example of an optimization like this is <strong>constant folding</strong>. Walk the
syntax tree in a bottom up fashion starting with the leaves of each expression.
When you encounter an arithmetic operator whose operands are both literal
numbers, do the math right then and replace the entire operator tree and its
operands with a new number literal syntax tree node containing the result value.</p>
<p>By running this optimization from the leaves up, you ensure subexpressions are
optimized out first, which lets you evaluate entire complex, nested arithmetic
expressions ahead of time into a single number.</p>
<p><strong>todo: fix overlap.</strong></p>
</aside>
<p>This pass works much like a simple <span name="abstract">interpreter</span> of
the syntax tree. It walks the tree, visiting each node. A couple of things make
it a static pass instead of a dynamic execution:</p>
<aside name="abstract">
<p><strong>Abstract interpretation</strong> is a compilation technique that further blurs the
line between static analysis and runtime execution.</p>
</aside>
<ul>
<li>
<p><strong>There are no side effects.</strong> When the static analysis visits a print
    statement, it doesn&rsquo;t actually print anything. Calls to native functions or
    other operations that reach out to the outside world are stubbed out and
    have no effect.</p>
</li>
<li>
<p><strong>There is no control flow.</strong> Loops are only visited once. Both branches are
    visited in if statements. Logic operators are not short-circuited. Each
    piece of syntax is touched exactly <span name="fix">once</span> and only
    once.</p>
</li>
</ul>
<aside name="fix">
<p>The simple variable resolution we&rsquo;ll do only touches each node once. It&rsquo;s
performance is <code>O(n)</code> where <code>n</code> is the number of nodes in the syntax tree. Some
more sophisticated static analyses may have greater algorithmic complexity and
need to do more work to calculate the answers they seek.</p>
<p>Most common analyses are carefully designed to be linear or not too far from it,
though. It&rsquo;s no fun if the compiler takes gets exponentially slower as your
program grows. It&rsquo;s an even more embarrassing faux pas to discover your
algorithm can get stuck in an infinite loop on some inputs.</p>
</aside>
<h2><a href="#a-resolver-class" name="a-resolver-class"><small>11&#8202;.&#8202;3</small> A Resolver Class</a></h2>
<p>Like everything in Java, our variable resolution pass will live in a class:</p>
<div class="codehilite"><div class="source-file"><em>lox/Resolver.java</em><br>
create new file</div>
<pre><span></span><span class="kn">package</span> <span class="nn">com.craftinginterpreters.lox</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.HashMap</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Map</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Stack</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Resolver</span> <span class="kd">implements</span> <span class="n">Expr</span><span class="o">.</span><span class="na">Visitor</span><span class="o">&lt;</span><span class="n">Void</span><span class="o">&gt;,</span> <span class="n">Stmt</span><span class="o">.</span><span class="na">Visitor</span><span class="o">&lt;</span><span class="n">Void</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="kd">final</span> <span class="n">Interpreter</span> <span class="n">interpreter</span><span class="o">;</span>

  <span class="n">Resolver</span><span class="o">(</span><span class="n">Interpreter</span> <span class="n">interpreter</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">interpreter</span> <span class="o">=</span> <span class="n">interpreter</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>

<p>Since it needs to &ldquo;visit&rdquo; every node in the syntax tree, it will implement the
handy Visitor abstraction we already have in place for exactly that. Only a
couple of nodes are interesting for purposes of resolving variables:</p>
<ul>
<li>
<p>A block statement introduces a new scope for the statements it contains, as
    does a function declaration for its body.</p>
</li>
<li>
<p>A variable declaration adds a new variable to the current scope.</p>
</li>
<li>
<p>Variable and assignment expressions need to have their variabl resolved.</p>
</li>
</ul>
<p>The rest of the nodes aren&rsquo;t particularly interesting, but we still need to
implement visit methods for them that traverse into their subtrees. Even though
a <code>+</code> expression doesn&rsquo;t <em>itself</em> have any variables to resolve, either of its
operands might be variables, or might contain them.</p>
<h3><a href="#resolving-blocks" name="resolving-blocks"><small>11&#8202;.&#8202;3&#8202;.&#8202;1</small> Resolving blocks</a></h3>
<p>We&rsquo;ll start with blocks since they create the local scopes that everything else
hinges on:</p>
<div class="codehilite"><div class="source-file"><em>lox/Resolver.java</em><br>
add after <em>Resolver</em>()</div>
<pre><span></span>  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="n">Void</span> <span class="nf">visitBlockStmt</span><span class="o">(</span><span class="n">Stmt</span><span class="o">.</span><span class="na">Block</span> <span class="n">stmt</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">beginScope</span><span class="o">();</span>
    <span class="n">resolve</span><span class="o">(</span><span class="n">stmt</span><span class="o">.</span><span class="na">statements</span><span class="o">);</span>
    <span class="n">endScope</span><span class="o">();</span>
    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
  <span class="o">}</span>
</pre></div>

<p>It begins a new scope, traverses into the statements inside the block, and then
discards that block scope. The fun stuff lives in those helper methods.</p>
<div class="codehilite"><div class="source-file"><em>lox/Resolver.java</em><br>
add after <em>Resolver</em>()</div>
<pre><span></span>  <span class="kt">void</span> <span class="nf">resolve</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Stmt</span><span class="o">&gt;</span> <span class="n">statements</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">Stmt</span> <span class="n">statement</span> <span class="o">:</span> <span class="n">statements</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">resolve</span><span class="o">(</span><span class="n">statement</span><span class="o">);</span>
    <span class="o">}</span>
  <span class="o">}</span>
</pre></div>

<p>The first one simply walks a list of statements and resolves each one. That in
turn calls:</p>
<div class="codehilite"><div class="source-file"><em>lox/Resolver.java</em><br>
add after <em>visitBlockStmt</em>()</div>
<pre><span></span>  <span class="kd">private</span> <span class="kt">void</span> <span class="nf">resolve</span><span class="o">(</span><span class="n">Stmt</span> <span class="n">stmt</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">stmt</span><span class="o">.</span><span class="na">accept</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
  <span class="o">}</span>
</pre></div>

<p>It&rsquo;s similar to the <code>evaluate()</code> and <code>execute()</code> methods in Interpreter&#8202;&mdash;&#8202;it
simply bounces back to apply the Visitor pattern to the given syntax tree node.</p>
<p>This is all pretty mundane. The real interesting stuff is around scope. A new
block scope is created using this:</p>
<div class="codehilite"><div class="source-file"><em>lox/Resolver.java</em><br>
add after <em>resolve</em>()</div>
<pre><span></span>  <span class="kd">private</span> <span class="kt">void</span> <span class="nf">beginScope</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">scopes</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Boolean</span><span class="o">&gt;());</span>
  <span class="o">}</span>
</pre></div>

<p>Lexical scopes nest and in both the interpreter and the resolver, they are
treated like a stack. The interpreter implements that stack using a linked
list&#8202;&mdash;&#8202;the chain of Environment objects. In the resolver, we use an actual
Java Stack:</p>
<div class="codehilite"><pre class="insert-before"><span></span>  <span class="kd">private</span> <span class="kd">final</span> <span class="n">Interpreter</span> <span class="n">interpreter</span><span class="o">;</span>
</pre><div class="source-file"><em>lox/Resolver.java</em><br>
in class <em>Resolver</em></div>
<pre class="insert"><span></span>  <span class="kd">private</span> <span class="kd">final</span> <span class="n">Stack</span><span class="o">&lt;</span><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Boolean</span><span class="o">&gt;&gt;</span> <span class="n">scopes</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Stack</span><span class="o">&lt;&gt;();</span>
</pre><pre class="insert-after"><br><span></span>  <span class="n">Resolver</span><span class="o">(</span><span class="n">Interpreter</span> <span class="n">interpreter</span><span class="o">)</span> <span class="o">{</span>
</pre></div>

<p>Each object in the stack is a Map that represents a single block scope. Keys,
as in Environment, are variable names. Values are different here. We&rsquo;ll get to
why they are Booleans soon.</p>
<p>The scope stack is only used for <em>local</em> block scopes. Variables declared at the
top level in the global scope are not tracked since those variables are a little
more dynamic in Lox. When resolving a variable, if we can&rsquo;t find it in the stack
of local scopes, we assume it must be global.</p>
<p>Since the scopes are tracked in an explicit stack, exiting a scope is
straightforward:</p>
<div class="codehilite"><div class="source-file"><em>lox/Resolver.java</em><br>
add after <em>beginScope</em>()</div>
<pre><span></span>  <span class="kd">private</span> <span class="kt">void</span> <span class="nf">endScope</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">scopes</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
  <span class="o">}</span>
</pre></div>

<p>This gives us a stack of empty scopes. To make them useful, next we&rsquo;ll handle
declarations.</p>
<h3><a href="#resolving-variable-declarations" name="resolving-variable-declarations"><small>11&#8202;.&#8202;3&#8202;.&#8202;2</small> Resolving variable declarations</a></h3>
<p>Resolving a variable declaration adds a new entry to the current innermost
scope&rsquo;s map. That seems simple, but there&rsquo;s a little dance we need to do:</p>
<div class="codehilite"><div class="source-file"><em>lox/Resolver.java</em><br>
add after <em>visitBlockStmt</em>()</div>
<pre><span></span>  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="n">Void</span> <span class="nf">visitVarStmt</span><span class="o">(</span><span class="n">Stmt</span><span class="o">.</span><span class="na">Var</span> <span class="n">stmt</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">declare</span><span class="o">(</span><span class="n">stmt</span><span class="o">.</span><span class="na">name</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">stmt</span><span class="o">.</span><span class="na">initializer</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">resolve</span><span class="o">(</span><span class="n">stmt</span><span class="o">.</span><span class="na">initializer</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="n">define</span><span class="o">(</span><span class="n">stmt</span><span class="o">.</span><span class="na">name</span><span class="o">);</span>
    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
  <span class="o">}</span>
</pre></div>

<p>Binding a new name in the scope takes two steps&#8202;&mdash;&#8202;declaring it, and defining
it. That&rsquo;s to handle this funny edge case:</p>
<div class="codehilite"><pre><span></span><span class="k">var</span> <span class="n">a</span> <span class="o">=</span> <span class="s">&quot;outer&quot;</span><span class="p">;</span>
<span class="p">{</span>
  <span class="k">var</span> <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>What happens when the initializer for a local variable refers to a variable with
the same name as what&rsquo;s being declared? We have a couple of options:</p>
<ul>
<li>
<p><strong>Treat the new variable as not in scope until <em>after</em> the initializer
    completes.</strong> That means here the new local <code>a</code> would be initialized with
    &ldquo;outer&rdquo;, the value of the <em>global</em> one. You can think of an initialized
    variable declaration as syntactic sugar for:</p>
<div class="codehilite"><pre><span></span><span class="k">var</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span> <span class="c1">// Run the initializer.</span>
<span class="k">var</span> <span class="n">a</span><span class="p">;</span>        <span class="c1">// Declare the variable.</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>     <span class="c1">// Initialize it.</span>
</pre></div>


</li>
<li>
<p><strong>Put the new variable in scope before its initializer is run.</strong> Of course,
    that raises the question of what value it has. After all, the initializer
    hasn&rsquo;t run yet. We&rsquo;d probably use <code>nil</code>. That means the new local <code>a</code> would
    be re-initialized to its own implicitly initialzed value, <code>nil</code>. It&rsquo;s as
    if every local variable declaration is:</p>
<div class="codehilite"><pre><span></span><span class="k">var</span> <span class="n">a</span><span class="p">;</span> <span class="c1">// Define the variable.</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span> <span class="c1">// Run the initializer.</span>
</pre></div>


</li>
<li>
<p><strong>Make it an error.</strong> If you look at the previous two options, do either of
    those look like something a user actually <em>wants</em>? Shadowing is rare and
    often an error so initializing a shadowing variable based on the value of
    the shadowed one seems unilkely to be deliberate.</p>
<p>The second option is even less useful. The new variable will <em>always</em> have
the value <code>nil</code>, there is never any point in mentioning it by name. You
could use an explicit <code>nil</code> instead.</p>
<p>Given that, it&rsquo;s reasonable to simply tell the user they probably made a
mistake by making it a syntax or runtime error to refer to a local variable
inside its own initializer.</p>
</li>
</ul>
<p>For Lox, we&rsquo;ll take the third option. Further, we&rsquo;ll make it a compile-time
error instead of a runtime one. That way, the user is alerted to the problem
before any code is run.</p>
<p>In order to do that, we need to keep track of which variables are in the
ephemeral state where we are in the middle of resolving their initializers. We
do that by splitting binding into two steps. The first is <em>declaring</em> it:</p>
<div class="codehilite"><div class="source-file"><em>lox/Resolver.java</em><br>
add after <em>endScope</em>()</div>
<pre><span></span>  <span class="kd">private</span> <span class="kt">void</span> <span class="nf">declare</span><span class="o">(</span><span class="n">Token</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">scopes</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="k">return</span><span class="o">;</span>

    <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Boolean</span><span class="o">&gt;</span> <span class="n">scope</span> <span class="o">=</span> <span class="n">scopes</span><span class="o">.</span><span class="na">peek</span><span class="o">();</span>
    <span class="n">scope</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">name</span><span class="o">.</span><span class="na">lexeme</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
  <span class="o">}</span>
</pre></div>

<p>This adds it to the innermost scope so that it shadows any outer one and so that
we know the variable exists. We mark it as &ldquo;not ready yet&rdquo; by binding its name
to <code>false</code> in the scope map. Each value in the scope map means &ldquo;is finished
being initialized&rdquo;.</p>
<p>Then we resolve the variable&rsquo;s initializer expression itself in the scope where
the new variable is declared but unavailable. Once the initializer expression is
done, the variable is ready for prime time. We do that by <em>defining</em> it:</p>
<div class="codehilite"><div class="source-file"><em>lox/Resolver.java</em><br>
add after <em>declare</em>()</div>
<pre><span></span>  <span class="kd">private</span> <span class="kt">void</span> <span class="nf">define</span><span class="o">(</span><span class="n">Token</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">scopes</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="k">return</span><span class="o">;</span>
    <span class="n">scopes</span><span class="o">.</span><span class="na">peek</span><span class="o">().</span><span class="na">put</span><span class="o">(</span><span class="n">name</span><span class="o">.</span><span class="na">lexeme</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>
  <span class="o">}</span>
</pre></div>

<p>Now we set the variable&rsquo;s value in the scope map to <code>true</code> to mark it as fully
initialized and available for use. It&rsquo;s alive!</p>
<h3><a href="#resolving-variable-expressions" name="resolving-variable-expressions"><small>11&#8202;.&#8202;3&#8202;.&#8202;3</small> Resolving variable expressions</a></h3>
<p>The other statement that binds a new name is function declarations, but before
we go there, let&rsquo;s see how variables are used. Now that are scopes contain some
stuff, we can resolve variable expressions:</p>
<div class="codehilite"><div class="source-file"><em>lox/Resolver.java</em><br>
add after <em>visitVarStmt</em>()</div>
<pre><span></span>  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="n">Void</span> <span class="nf">visitVariableExpr</span><span class="o">(</span><span class="n">Expr</span><span class="o">.</span><span class="na">Variable</span> <span class="n">expr</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">scopes</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span>
        <span class="n">scopes</span><span class="o">.</span><span class="na">peek</span><span class="o">().</span><span class="na">get</span><span class="o">(</span><span class="n">expr</span><span class="o">.</span><span class="na">name</span><span class="o">.</span><span class="na">lexeme</span><span class="o">)</span> <span class="o">==</span> <span class="n">Boolean</span><span class="o">.</span><span class="na">FALSE</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">Lox</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="n">expr</span><span class="o">.</span><span class="na">name</span><span class="o">,</span>
          <span class="s">&quot;Cannot read local variable in its own initializer.&quot;</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="n">resolveLocal</span><span class="o">(</span><span class="n">expr</span><span class="o">,</span> <span class="n">expr</span><span class="o">.</span><span class="na">name</span><span class="o">);</span>
    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
  <span class="o">}</span>
</pre></div>

<p>First, we check to see if the variable is being accessed inside its own
initializer. This is where the values in the scope map come into play. If the
variable exists in the current scope but it&rsquo;s value is <code>false</code>, that means we
have declared it but not yet defined. We report that error.</p>
<p>We only do this check for local variables. We allow global variables to be
re-declared to make the REPL a little more friendly. In that case, allowing a
global to mention its previous incarnation can be handy, though admittedly odd
looking.</p>
<p>After that check, we actually resolve the variable itself using this:</p>
<div class="codehilite"><div class="source-file"><em>lox/Resolver.java</em><br>
add after <em>define</em>()</div>
<pre><span></span>  <span class="kd">private</span> <span class="kt">void</span> <span class="nf">resolveLocal</span><span class="o">(</span><span class="n">Expr</span> <span class="n">expr</span><span class="o">,</span> <span class="n">Token</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">scopes</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">--)</span> <span class="o">{</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">scopes</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">).</span><span class="na">containsKey</span><span class="o">(</span><span class="n">name</span><span class="o">.</span><span class="na">lexeme</span><span class="o">))</span> <span class="o">{</span>
        <span class="n">interpreter</span><span class="o">.</span><span class="na">resolve</span><span class="o">(</span><span class="n">expr</span><span class="o">,</span> <span class="n">scopes</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">i</span><span class="o">);</span>
        <span class="k">return</span><span class="o">;</span>
      <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// Not found. Assume it is global.</span>
  <span class="o">}</span>
</pre></div>

<p>This looks, for good reason, a lot like the code in Environment for looking up a
variable. We start at the innermost scope and work outwards, looking in each map
for a matching name. If we find the variable, we tell the interpreter to resolve
it, passing in the number of scopes between the current innermost scope and the
scope enclosing where the variable was found. So, if the variable was found in
the current scope, it passes in 0. If it&rsquo;s in the immediately enclosing scope,
1. You get the idea.</p>
<p>We&rsquo;ll get to the implementation of that method a little later. For now, let&rsquo;s
keep on cranking through other syntax nodes.</p>
<h3><a href="#resolving-function-declarations" name="resolving-function-declarations"><small>11&#8202;.&#8202;3&#8202;.&#8202;4</small> Resolving function declarations</a></h3>
<p>The other statement form that binds names is a function declaration. It binds
the name of the function itself in the scope where it&rsquo;s declared, and also binds
names for the function&rsquo;s parameters inside its body.</p>
<div class="codehilite"><div class="source-file"><em>lox/Resolver.java</em><br>
add after <em>visitBlockStmt</em>()</div>
<pre><span></span>  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="n">Void</span> <span class="nf">visitFunctionStmt</span><span class="o">(</span><span class="n">Stmt</span><span class="o">.</span><span class="na">Function</span> <span class="n">stmt</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">declare</span><span class="o">(</span><span class="n">stmt</span><span class="o">.</span><span class="na">name</span><span class="o">);</span>
    <span class="n">define</span><span class="o">(</span><span class="n">stmt</span><span class="o">.</span><span class="na">name</span><span class="o">);</span>

    <span class="n">resolveFunction</span><span class="o">(</span><span class="n">stmt</span><span class="o">,</span> <span class="n">FunctionType</span><span class="o">.</span><span class="na">FUNCTION</span><span class="o">);</span>
    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
  <span class="o">}</span>
</pre></div>

<p>Similar to <code>visitVariableStmt()</code>, it declares and then defines the name of the
function in the current scope. Unlike variables, though, it defines the name
eagerly, before stepping into the function&rsquo;s body. This lets a function refer to
itself inside its own body for recursion, even if the function is declared
inside a block or other function. This is safe because the reference to the
function won&rsquo;t be <em>executed</em> until the function is called, which can&rsquo;t happen
until the declaration has finished.</p>
<p>Then it handles the function by using this:</p>
<div class="codehilite"><div class="source-file"><em>lox/Resolver.java</em><br>
add after <em>resolve</em>()</div>
<pre><span></span>  <span class="kd">private</span> <span class="kt">void</span> <span class="nf">resolveFunction</span><span class="o">(</span><span class="n">Stmt</span><span class="o">.</span><span class="na">Function</span> <span class="n">function</span><span class="o">,</span> <span class="n">FunctionType</span> <span class="n">type</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">beginScope</span><span class="o">();</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">Token</span> <span class="n">param</span> <span class="o">:</span> <span class="n">function</span><span class="o">.</span><span class="na">parameters</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">declare</span><span class="o">(</span><span class="n">param</span><span class="o">);</span>
      <span class="n">define</span><span class="o">(</span><span class="n">param</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="n">resolve</span><span class="o">(</span><span class="n">function</span><span class="o">.</span><span class="na">body</span><span class="o">);</span>
    <span class="n">endScope</span><span class="o">();</span>
  <span class="o">}</span>
</pre></div>

<p>It&rsquo;s a separate method since we will also use it later for resolving Lox class
methods. Similar to a block, it pushes a new scope for the function&rsquo;s body. Then
it defines variables for each of the function&rsquo;s parameters.</p>
<p>Once that&rsquo;s done, it resolves the function body in that scope. This is different
from how the interpreter handles function declarations. At <em>runtime</em> declaring a
function doesn&rsquo;t do anything with the function&rsquo;s body. That doesn&rsquo;t get touched
until later when the function is called. In a <em>static</em> analysis, we immediately
traverse into the body right then and there.</p>
<h3><a href="#resolving-assignment-expressions" name="resolving-assignment-expressions"><small>11&#8202;.&#8202;3&#8202;.&#8202;5</small> Resolving assignment expressions</a></h3>
<p>Variables are &ldquo;used&rdquo; by being read, but also by being written, so we also need
to resolve them in assignments. It looks like this:</p>
<div class="codehilite"><div class="source-file"><em>lox/Resolver.java</em><br>
add after <em>visitVarStmt</em>()</div>
<pre><span></span>  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="n">Void</span> <span class="nf">visitAssignExpr</span><span class="o">(</span><span class="n">Expr</span><span class="o">.</span><span class="na">Assign</span> <span class="n">expr</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">resolve</span><span class="o">(</span><span class="n">expr</span><span class="o">.</span><span class="na">value</span><span class="o">);</span>
    <span class="n">resolveLocal</span><span class="o">(</span><span class="n">expr</span><span class="o">,</span> <span class="n">expr</span><span class="o">.</span><span class="na">name</span><span class="o">);</span>
    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
  <span class="o">}</span>
</pre></div>

<p>We resolve the expression that calculates the value being assigned in case it
also contains references to other variables using this helper:</p>
<div class="codehilite"><div class="source-file"><em>lox/Resolver.java</em><br>
in <em>resolve</em>()</div>
<pre><span></span>  <span class="kd">private</span> <span class="kt">void</span> <span class="nf">resolve</span><span class="o">(</span><span class="n">Expr</span> <span class="n">expr</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">expr</span><span class="o">.</span><span class="na">accept</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
  <span class="o">}</span>
</pre></div>

<p>Then we use our existing <code>resolveLocal()</code> to resolve the variable that&rsquo;s being
assigned to. Since an assignment doesn&rsquo;t modify the scope, these could be done
in either order.</p>
<h3><a href="#resolving-the-other-syntax-tree-nodes" name="resolving-the-other-syntax-tree-nodes"><small>11&#8202;.&#8202;3&#8202;.&#8202;6</small> Resolving the other syntax tree nodes</a></h3>
<p>That covers all of the interesting corners of the syntax tree. We handle every
place where a variable is declared, read or written, and every place where a
scope is created or destroyed.</p>
<p>All that remains is to implement visit methods for the other syntax tree nodes
to recurse into their subtrees. Even though there&rsquo;s nothing interesting to do
with variables in a binary operator itself, either operand may contain a
variable, so we need to traverse through it.</p>
<p><strong>todo: illustrate ast with var in leaf</strong></p>
<p>We&rsquo;ll go kind of &ldquo;top down&rdquo; and start with statements. This is going to be kind
of slog, so let&rsquo;s just grind through it.</p>
<div class="codehilite"><div class="source-file"><em>lox/Resolver.java</em><br>
add after <em>visitBlockStmt</em>()</div>
<pre><span></span>  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="n">Void</span> <span class="nf">visitExpressionStmt</span><span class="o">(</span><span class="n">Stmt</span><span class="o">.</span><span class="na">Expression</span> <span class="n">stmt</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">resolve</span><span class="o">(</span><span class="n">stmt</span><span class="o">.</span><span class="na">expression</span><span class="o">);</span>
    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
  <span class="o">}</span>
</pre></div>

<p>An expression statement contains a single expression to traverse.</p>
<div class="codehilite"><div class="source-file"><em>lox/Resolver.java</em><br>
add after <em>visitFunctionStmt</em>()</div>
<pre><span></span>  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="n">Void</span> <span class="nf">visitIfStmt</span><span class="o">(</span><span class="n">Stmt</span><span class="o">.</span><span class="na">If</span> <span class="n">stmt</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">resolve</span><span class="o">(</span><span class="n">stmt</span><span class="o">.</span><span class="na">condition</span><span class="o">);</span>
    <span class="n">resolve</span><span class="o">(</span><span class="n">stmt</span><span class="o">.</span><span class="na">thenBranch</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">stmt</span><span class="o">.</span><span class="na">elseBranch</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="n">resolve</span><span class="o">(</span><span class="n">stmt</span><span class="o">.</span><span class="na">elseBranch</span><span class="o">);</span>
    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
  <span class="o">}</span>
</pre></div>

<p>Here, we can see how resolution is different from interpretation. When we
resolve an if statement, there is no control flow. We resolve the condition and
<em>both</em> branches. Where a dynamic execution only steps into the branch that <em>is</em>
run, a static analysis is conservative&#8202;&mdash;&#8202;it analyzes any branch that <em>could</em> be
run. Since either one could be reached at runtime, it resolves both.</p>
<p>Moving along&hellip;</p>
<div class="codehilite"><div class="source-file"><em>lox/Resolver.java</em><br>
add after <em>visitIfStmt</em>()</div>
<pre><span></span>  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="n">Void</span> <span class="nf">visitPrintStmt</span><span class="o">(</span><span class="n">Stmt</span><span class="o">.</span><span class="na">Print</span> <span class="n">stmt</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">resolve</span><span class="o">(</span><span class="n">stmt</span><span class="o">.</span><span class="na">expression</span><span class="o">);</span>
    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
  <span class="o">}</span>
</pre></div>

<p>Like expression statements, this resolves the single expression.</p>
<div class="codehilite"><div class="source-file"><em>lox/Resolver.java</em><br>
add after <em>visitPrintStmt</em>()</div>
<pre><span></span>  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="n">Void</span> <span class="nf">visitReturnStmt</span><span class="o">(</span><span class="n">Stmt</span><span class="o">.</span><span class="na">Return</span> <span class="n">stmt</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">stmt</span><span class="o">.</span><span class="na">value</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">resolve</span><span class="o">(</span><span class="n">stmt</span><span class="o">.</span><span class="na">value</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
  <span class="o">}</span>
</pre></div>

<p>Same deal.</p>
<div class="codehilite"><div class="source-file"><em>lox/Resolver.java</em><br>
add after <em>visitVarStmt</em>()</div>
<pre><span></span>  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="n">Void</span> <span class="nf">visitWhileStmt</span><span class="o">(</span><span class="n">Stmt</span><span class="o">.</span><span class="na">While</span> <span class="n">stmt</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">resolve</span><span class="o">(</span><span class="n">stmt</span><span class="o">.</span><span class="na">condition</span><span class="o">);</span>
    <span class="n">resolve</span><span class="o">(</span><span class="n">stmt</span><span class="o">.</span><span class="na">body</span><span class="o">);</span>
    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
  <span class="o">}</span>
</pre></div>

<p>Like if statements, for while, we resolve the condition and alway resolve the
body exactly once. That covers all the statements.</p>
<div class="codehilite"><div class="source-file"><em>lox/Resolver.java</em><br>
add after <em>visitAssignExpr</em>()</div>
<pre><span></span>  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="n">Void</span> <span class="nf">visitBinaryExpr</span><span class="o">(</span><span class="n">Expr</span><span class="o">.</span><span class="na">Binary</span> <span class="n">expr</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">resolve</span><span class="o">(</span><span class="n">expr</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
    <span class="n">resolve</span><span class="o">(</span><span class="n">expr</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
  <span class="o">}</span>
</pre></div>

<p>Our old friend the binary expression. We traverse into and resolve both
operands.</p>
<div class="codehilite"><div class="source-file"><em>lox/Resolver.java</em><br>
add after <em>visitBinaryExpr</em>()</div>
<pre><span></span>  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="n">Void</span> <span class="nf">visitCallExpr</span><span class="o">(</span><span class="n">Expr</span><span class="o">.</span><span class="na">Call</span> <span class="n">expr</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">resolve</span><span class="o">(</span><span class="n">expr</span><span class="o">.</span><span class="na">callee</span><span class="o">);</span>

    <span class="k">for</span> <span class="o">(</span><span class="n">Expr</span> <span class="n">argument</span> <span class="o">:</span> <span class="n">expr</span><span class="o">.</span><span class="na">arguments</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">resolve</span><span class="o">(</span><span class="n">argument</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
  <span class="o">}</span>
</pre></div>

<p>Calls are similar&#8202;&mdash;&#8202;we walk the argument list and resolve them all. The thing
being called is also an expression (usually a variable expression) so that gets
resolved to.</p>
<div class="codehilite"><div class="source-file"><em>lox/Resolver.java</em><br>
add after <em>visitCallExpr</em>()</div>
<pre><span></span>  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="n">Void</span> <span class="nf">visitGroupingExpr</span><span class="o">(</span><span class="n">Expr</span><span class="o">.</span><span class="na">Grouping</span> <span class="n">expr</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">resolve</span><span class="o">(</span><span class="n">expr</span><span class="o">.</span><span class="na">expression</span><span class="o">);</span>
    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
  <span class="o">}</span>
</pre></div>

<p>This one&rsquo;s pretty easy.</p>
<div class="codehilite"><div class="source-file"><em>lox/Resolver.java</em><br>
add after <em>visitGroupingExpr</em>()</div>
<pre><span></span>  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="n">Void</span> <span class="nf">visitLiteralExpr</span><span class="o">(</span><span class="n">Expr</span><span class="o">.</span><span class="na">Literal</span> <span class="n">expr</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
  <span class="o">}</span>
</pre></div>

<p>This is even easier. Since a literal expression doesn&rsquo;t mention any variables
and doesn&rsquo;t contain any subexpressions, there is no work to do at all.</p>
<div class="codehilite"><div class="source-file"><em>lox/Resolver.java</em><br>
add after <em>visitLiteralExpr</em>()</div>
<pre><span></span>  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="n">Void</span> <span class="nf">visitLogicalExpr</span><span class="o">(</span><span class="n">Expr</span><span class="o">.</span><span class="na">Logical</span> <span class="n">expr</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">resolve</span><span class="o">(</span><span class="n">expr</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
    <span class="n">resolve</span><span class="o">(</span><span class="n">expr</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
  <span class="o">}</span>
</pre></div>

<p>Since a static analysis does no control flow or short-circuiting, logical
expressions are exactly the same as other binary operators.</p>
<div class="codehilite"><div class="source-file"><em>lox/Resolver.java</em><br>
add after <em>visitLogicalExpr</em>()</div>
<pre><span></span>  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="n">Void</span> <span class="nf">visitUnaryExpr</span><span class="o">(</span><span class="n">Expr</span><span class="o">.</span><span class="na">Unary</span> <span class="n">expr</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">resolve</span><span class="o">(</span><span class="n">expr</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
  <span class="o">}</span>
</pre></div>

<p>And, finally, the last node. We just resolve its one operand. If we did that all
right, now our Java compiler should be satisfied that we&rsquo;ve fully implemented
Stmt.Visitor and Expr.Visitor</p>
<hr />
<h2><a href="#interpreting-resolved-variables" name="interpreting-resolved-variables"><small>11&#8202;.&#8202;4</small> Interpreting Resolved Variables</a></h2>
<p>OK, that&rsquo;s our resolver. What does it actually do? It looks at every
mention of a variable in the user&rsquo;s program. For each one, the resolver tracks
down the declaration that it refers to. Then it counts the number of scopes
between the use of the variable and its declaration.</p>
<p>At runtime, this corresponds exactly to the number of <em>environments</em> between the
current one and the enclosing one where interpreter can find the variable&rsquo;s
value. The resolver gives that to the interpreter by calling this:</p>
<div class="codehilite"><div class="source-file"><em>lox/Interpreter.java</em><br>
add after <em>execute</em>()</div>
<pre><span></span>  <span class="kt">void</span> <span class="nf">resolve</span><span class="o">(</span><span class="n">Expr</span> <span class="n">expr</span><span class="o">,</span> <span class="kt">int</span> <span class="n">depth</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">locals</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">expr</span><span class="o">,</span> <span class="n">depth</span><span class="o">);</span>
  <span class="o">}</span>
</pre></div>

<p>We want to store the resolution information somewhere so we can use it when the
variable use is later executed, but where? One obvious place is on the variable
expression or assignment expression itself&#8202;&mdash;&#8202;right in the syntax tree nodes.
That&rsquo;s a fine approach, and that&rsquo;s where many compilers store the results of
their static analysis.</p>
<p>We could do that, but it would require mucking around with our syntax tree
generator. Instead, we&rsquo;ll take another common approach and store it off to the
<span name="side">side</span> in a map that associates each syntax tree node
with its resolved data.</p>
<aside name="side">
<p>I&rsquo;ve heard this called a &ldquo;side table&rdquo; since the map is sort of a tabular data
structure that tracks some information off to the side. But every time I try to
Google the literature to find more background on this term, I just get pages
about furniture.</p>
<p>One nice thing about using a side table to store static analysis results, is
that it makes it easy to <em>discard</em> the data. In an IDE or interactive editor
where you may often incrementally reparse and resolve parts of the user&rsquo;s
program, it can become difficult to track down which state stored in variable
syntax tree nodes has become invalidated and needs to be recalculated.</p>
<p>If it all lives in a single table, you can clear the whole thing in one fell
swoop.</p>
</aside>
<p>The map is a new field on the Interpreter class:</p>
<div class="codehilite"><pre class="insert-before"><span></span>  <span class="kd">private</span> <span class="n">Environment</span> <span class="n">environment</span> <span class="o">=</span> <span class="n">globals</span><span class="o">;</span>
</pre><div class="source-file"><em>lox/Interpreter.java</em><br>
in class <em>Interpreter</em></div>
<pre class="insert"><span></span>  <span class="kd">private</span> <span class="kd">final</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">Expr</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">locals</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;&gt;();</span>
</pre><pre class="insert-after"><br><span></span>  <span class="n">Interpreter</span><span class="o">()</span> <span class="o">{</span>
</pre></div>

<p>You might think we&rsquo;d need some sort of nested tree structure to keep track of
each use of a variable and avoid getting confused when there are multiple
expressions that reference the same variable. But each variable <em>expression</em> is
its own Java object with its own unique identity. A single monolithic Map for
the entire program or REPL session won&rsquo;t have any trouble keeping them
separated.</p>
<p>As usual, using a collection requires us to import a couple of names:</p>
<div class="codehilite"><pre class="insert-before"><span></span><span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
</pre><div class="source-file"><em>lox/Interpreter.java</em></div>
<pre class="insert"><span></span><span class="kn">import</span> <span class="nn">java.util.HashMap</span><span class="o">;</span>
</pre><pre class="insert-after"><span></span><span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>
</pre></div>

<p>And:</p>
<div class="codehilite"><pre class="insert-before"><span></span><span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>
</pre><div class="source-file"><em>lox/Interpreter.java</em></div>
<pre class="insert"><span></span><span class="kn">import</span> <span class="nn">java.util.Map</span><span class="o">;</span>
</pre><pre class="insert-after"><br><span></span><span class="kd">class</span> <span class="nc">Interpreter</span> <span class="kd">implements</span> <span class="n">Expr</span><span class="o">.</span><span class="na">Visitor</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;,</span> <span class="n">Stmt</span><span class="o">.</span><span class="na">Visitor</span><span class="o">&lt;</span><span class="n">Void</span><span class="o">&gt;</span> <span class="o">{</span>
</pre></div>

<h3><a href="#accessing-a-resolved-variable" name="accessing-a-resolved-variable"><small>11&#8202;.&#8202;4&#8202;.&#8202;1</small> Accessing a resolved variable</a></h3>
<p>Our interpreter now has access to each variable&rsquo;s resolved location. Finally we
get to make some use of that. We replace the visit method for variable
expressions with this:</p>
<div class="codehilite"><pre class="insert-before"><span></span>  <span class="kd">public</span> <span class="n">Object</span> <span class="nf">visitVariableExpr</span><span class="o">(</span><span class="n">Expr</span><span class="o">.</span><span class="na">Variable</span> <span class="n">expr</span><span class="o">)</span> <span class="o">{</span>
</pre><div class="source-file"><em>lox/Interpreter.java</em><br>
in <em>visitVariableExpr</em>()<br>
replace 1 line</div>
<pre class="insert"><span></span>    <span class="k">return</span> <span class="n">lookUpVariable</span><span class="o">(</span><span class="n">expr</span><span class="o">.</span><span class="na">name</span><span class="o">,</span> <span class="n">expr</span><span class="o">);</span>
</pre><pre class="insert-after"><span></span>  <span class="o">}</span>
</pre></div>

<p>That delegates to:</p>
<div class="codehilite"><div class="source-file"><em>lox/Interpreter.java</em><br>
add after <em>visitVariableExpr</em>()</div>
<pre><span></span>  <span class="kd">private</span> <span class="n">Object</span> <span class="nf">lookUpVariable</span><span class="o">(</span><span class="n">Token</span> <span class="n">name</span><span class="o">,</span> <span class="n">Expr</span> <span class="n">expr</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">Integer</span> <span class="n">distance</span> <span class="o">=</span> <span class="n">locals</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">expr</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">distance</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">return</span> <span class="n">environment</span><span class="o">.</span><span class="na">getAt</span><span class="o">(</span><span class="n">distance</span><span class="o">,</span> <span class="n">name</span><span class="o">.</span><span class="na">lexeme</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
      <span class="k">return</span> <span class="n">globals</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
    <span class="o">}</span>
  <span class="o">}</span>
</pre></div>

<p>There&rsquo;s a couple of things going on here. First, we look up the resolved
distance in the map. Remember that we only resolved <em>local</em> variables. Globals
are treated specially and don&rsquo;t end up in the map (hence the name <code>locals</code>). So,
if we don&rsquo;t find the distance in the map, it must be global. In that case, we
look it up, dynamically, in the global environment. That throws a runtime error
if the variable isn&rsquo;t defined.</p>
<p>If we <em>did</em> get a distance, we have a local variable, and we get to take
advantage of the results of our static analysis. Instead of calling <code>get()</code>, we
call this new method on Environment:</p>
<div class="codehilite"><div class="source-file"><em>lox/Environment.java</em><br>
add after <em>define</em>()</div>
<pre><span></span>  <span class="n">Object</span> <span class="nf">getAt</span><span class="o">(</span><span class="kt">int</span> <span class="n">distance</span><span class="o">,</span> <span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">Environment</span> <span class="n">environment</span> <span class="o">=</span> <span class="k">this</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">distance</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
      <span class="n">environment</span> <span class="o">=</span> <span class="n">environment</span><span class="o">.</span><span class="na">enclosing</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="n">environment</span><span class="o">.</span><span class="na">values</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">name</span><span class="o">);</span> <span name="coupled"></span>
  <span class="o">}</span>
</pre></div>

<p>The old <code>get()</code> method dynamically walks the chain of enclosing environments,
scouring each one to see if the variable might be hiding in there somewhere.
But, now, we know exactly which environment in the chain will have the variable.
We simply walk that many hops along the environment chain, and return the
variable&rsquo;s value in that map. We don&rsquo;t even have to check to see if the variable
is there&#8202;&mdash;&#8202;we know it will be because the resolver already found it there.</p>
<aside name="coupled">
<p>The way the interpreter assumes the variable will be in that map feels like
flying blind to me. The interpreter is trusting that the resolver did its job
and resolved the variable correctly. This means there is a deep coupling between
these two classes. Each line line of code in the resolver that touches a scope
must have its exact match in the interpreter for modifying an environment.</p>
<p>I felt that coupling that first-hand because as I implemented them for the book,
I ran into a number of subtle bugs where the resolver and interpreter code were
slightly out of sync. Tracking those down was difficult. One tool to make that
easier is to have the interpreter explicitly assert&#8202;&mdash;&#8202;using Java&rsquo;s assert
statements or some other validation tool&#8202;&mdash;&#8202;the contract it expects the resolver
to have already upheld.</p>
<p>Even so, expect to have to pay close attention when you change either the
resolver or interpreter and think carefully about whether that requires a
corresponding change in the other pass.</p>
<p><strong>todo: overlap</strong></p>
</aside>
<h3><a href="#assigning-to-a-resolved-variable" name="assigning-to-a-resolved-variable"><small>11&#8202;.&#8202;4&#8202;.&#8202;2</small> Assigning to a resolved variable</a></h3>
<p>The other way a variable is used is when it&rsquo;s written. The changes to visiting
an assignment statement are similar:</p>
<div class="codehilite"><pre class="insert-before"><span></span>    <span class="n">Object</span> <span class="n">value</span> <span class="o">=</span> <span class="n">evaluate</span><span class="o">(</span><span class="n">expr</span><span class="o">.</span><span class="na">value</span><span class="o">);</span>
<br></pre><div class="source-file"><em>lox/Interpreter.java</em><br>
in <em>visitAssignExpr</em>()<br>
replace 1 line</div>
<pre class="insert"><span></span>    <span class="n">Integer</span> <span class="n">distance</span> <span class="o">=</span> <span class="n">locals</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">expr</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">distance</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">environment</span><span class="o">.</span><span class="na">assignAt</span><span class="o">(</span><span class="n">distance</span><span class="o">,</span> <span class="n">expr</span><span class="o">.</span><span class="na">name</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
      <span class="n">globals</span><span class="o">.</span><span class="na">assign</span><span class="o">(</span><span class="n">expr</span><span class="o">.</span><span class="na">name</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
    <span class="o">}</span>
<br></pre><pre class="insert-after"><span></span>    <span class="k">return</span> <span class="n">value</span><span class="o">;</span>
</pre></div>

<p>Again, we look up the variable&rsquo;s scope distance. If not found, we assume it&rsquo;s
global and handle it the way as before. Otherwise, we call this new method:</p>
<div class="codehilite"><div class="source-file"><em>lox/Environment.java</em><br>
add after <em>getAt</em>()</div>
<pre><span></span>  <span class="kt">void</span> <span class="nf">assignAt</span><span class="o">(</span><span class="kt">int</span> <span class="n">distance</span><span class="o">,</span> <span class="n">Token</span> <span class="n">name</span><span class="o">,</span> <span class="n">Object</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">Environment</span> <span class="n">environment</span> <span class="o">=</span> <span class="k">this</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">distance</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
      <span class="n">environment</span> <span class="o">=</span> <span class="n">environment</span><span class="o">.</span><span class="na">enclosing</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="n">environment</span><span class="o">.</span><span class="na">values</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">name</span><span class="o">.</span><span class="na">lexeme</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
  <span class="o">}</span>
</pre></div>

<p>As <code>getAt()</code> is to <code>get()</code>, this is to <code>assign()</code>. It walks a fixed number of
enviroments, and then stuffs the new value in that map.</p>
<p>Those are the only changes to our interpreter. This is why we chose a
representation for our resolved data that was minimally invasive. All of the
rest of the nodes continue working just as they did before. Even the code for
modifying environments is unchanged.</p>
<h2><a href="#running-the-resolver" name="running-the-resolver"><small>11&#8202;.&#8202;5</small> Running the Resolver</a></h2>
<p>We do need to actually <em>run</em> the resolver, though. We insert the new pass after
the the parser does it&rsquo;s magic:</p>
<div class="codehilite"><pre class="insert-before"><span></span>    <span class="c1">// Stop if there was a syntax error.</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">hadError</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>
<br></pre><div class="source-file"><em>lox/Lox.java</em><br>
in <em>run</em>()</div>
<pre class="insert"><span></span>    <span class="n">Resolver</span> <span class="n">resolver</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Resolver</span><span class="o">(</span><span class="n">interpreter</span><span class="o">);</span>
    <span class="n">resolver</span><span class="o">.</span><span class="na">resolve</span><span class="o">(</span><span class="n">statements</span><span class="o">);</span>
<br></pre><pre class="insert-after"><span></span>    <span class="n">interpreter</span><span class="o">.</span><span class="na">interpret</span><span class="o">(</span><span class="n">statements</span><span class="o">);</span>
</pre></div>

<p>We don&rsquo;t run the resolver if there are any parse errors. If the code has a
syntax error, it&rsquo;s never going to run, so there&rsquo;s little value in resolving it.
Otherwise, we tell the resolver to do it&rsquo;s thing. It has a reference to the
interpreter and pokes the resolved data directly into it as it walks over
variables. When we next run the interpreter, it has everything it needs.</p>
<p>At least, that&rsquo;s true if the resolver <em>succeeded</em>. But what about errors during
resolution itself?</p>
<h3><a href="#resolution-errors" name="resolution-errors"><small>11&#8202;.&#8202;5&#8202;.&#8202;1</small> Resolution errors</a></h3>
<p>Since we are doing a static analysis pass, we have an opportunity to make Lox&rsquo;s
semantics more precise, and to help users catch more bugs early before running
their code. Take a look at this bad boy:</p>
<div class="codehilite"><pre><span></span><span class="k">fun</span> <span class="n">bad</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">var</span> <span class="n">a</span> <span class="o">=</span> <span class="s">&quot;first&quot;</span><span class="p">;</span>
  <span class="k">var</span> <span class="n">a</span> <span class="o">=</span> <span class="s">&quot;second&quot;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>We do allow declaring multiple variables with the same name in the <em>global</em>
scope, but doing so in a local scope is probably a mistake. If they knew the
variable already existed, they would assign to it instead of using <code>var</code>. And if
they <em>didn&rsquo;t</em> know it existed, they probably don&rsquo;t intend to overwrite the
previous one.</p>
<p>We can detect this statically while resolving:</p>
<div class="codehilite"><pre class="insert-before"><span></span>    <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Boolean</span><span class="o">&gt;</span> <span class="n">scope</span> <span class="o">=</span> <span class="n">scopes</span><span class="o">.</span><span class="na">peek</span><span class="o">();</span>
</pre><div class="source-file"><em>lox/Resolver.java</em><br>
in <em>declare</em>()</div>
<pre class="insert"><span></span>    <span class="k">if</span> <span class="o">(</span><span class="n">scope</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">name</span><span class="o">.</span><span class="na">lexeme</span><span class="o">))</span> <span class="o">{</span>
      <span class="n">Lox</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="n">name</span><span class="o">,</span>
          <span class="s">&quot;Variable with this name already declared in this scope.&quot;</span><span class="o">);</span>
    <span class="o">}</span>
<br></pre><pre class="insert-after"><span></span>    <span class="n">scope</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">name</span><span class="o">.</span><span class="na">lexeme</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
</pre></div>

<p>When we declare a variable in a local scope, we already know the names of every
variable previously declared in that same scope. If we see a collision, we
report an error.</p>
<h3><a href="#invalid-return-errors" name="invalid-return-errors"><small>11&#8202;.&#8202;5&#8202;.&#8202;2</small> Invalid return errors</a></h3>
<p>Here&rsquo;s a another nasty little script:</p>
<div class="codehilite"><pre><span></span><span class="k">return</span> <span class="s">&quot;at top level&quot;</span><span class="p">;</span>
</pre></div>


<p>This is executing a return statement but it&rsquo;s not even inside a function at all.
It&rsquo;s top level code. I don&rsquo;t know what the user <em>thinks</em> is going to happen, but
I don&rsquo;t think we want Lox to allow this.</p>
<p>We can extend the resolver to detect this statically. Much like it tracks scopes
as it walks the tree, it can track whether or not the current code is inside a
function declaration or not:</p>
<div class="codehilite"><pre class="insert-before"><span></span>  <span class="kd">private</span> <span class="kd">final</span> <span class="n">Stack</span><span class="o">&lt;</span><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Boolean</span><span class="o">&gt;&gt;</span> <span class="n">scopes</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Stack</span><span class="o">&lt;&gt;();</span>
</pre><div class="source-file"><em>lox/Resolver.java</em><br>
in class <em>Resolver</em></div>
<pre class="insert"><span></span><span class="kd">private</span> <span class="n">FunctionType</span> <span class="n">currentFunction</span> <span class="o">=</span> <span class="n">FunctionType</span><span class="o">.</span><span class="na">NONE</span><span class="o">;</span>
</pre><pre class="insert-after"><br><span></span>  <span class="n">Resolver</span><span class="o">(</span><span class="n">Interpreter</span> <span class="n">interpreter</span><span class="o">)</span> <span class="o">{</span>
</pre></div>

<p>Instead of a bare Boolean, it uses this funny enum:</p>
<div class="codehilite"><div class="source-file"><em>lox/Resolver.java</em><br>
add after <em>Resolver</em>()</div>
<pre><span></span>  <span class="kd">private</span> <span class="kd">enum</span> <span class="n">FunctionType</span> <span class="o">{</span>
    <span class="n">NONE</span><span class="o">,</span>
    <span class="n">FUNCTION</span>
  <span class="o">}</span>
</pre></div>

<p>It seems kind of dumb now, but we&rsquo;ll add a couple more cases to it later and
then it will make more sense. When we resolve a function declaration, we set
this field before resolving the body.</p>
<div class="codehilite"><pre class="insert-before"><span></span>  <span class="kd">private</span> <span class="kt">void</span> <span class="nf">resolveFunction</span><span class="o">(</span><span class="n">Stmt</span><span class="o">.</span><span class="na">Function</span> <span class="n">function</span><span class="o">,</span> <span class="n">FunctionType</span> <span class="n">type</span><span class="o">)</span> <span class="o">{</span>
</pre><div class="source-file"><em>lox/Resolver.java</em><br>
in <em>resolveFunction</em>()</div>
<pre class="insert"><span></span>    <span class="n">FunctionType</span> <span class="n">enclosingFunction</span> <span class="o">=</span> <span class="n">currentFunction</span><span class="o">;</span>
    <span class="n">currentFunction</span> <span class="o">=</span> <span class="n">type</span><span class="o">;</span>
<br></pre><pre class="insert-after"><span></span>    <span class="n">beginScope</span><span class="o">();</span>
</pre></div>

<p>We stash the previous value of that field in a local variable first. Remember,
Lox has local functions, so you can nest function declarations arbitrarily
deeply. We need to keep track not just that we&rsquo;re in a function, but <em>how many</em>
we&rsquo;re in.</p>
<p>We could use an explicit stack of FunctionType values for that, but instead
we&rsquo;ll piggyback on the Java stack. We store the previous value in a local on the
Java stack. When we&rsquo;re done resolving the function body, we restore the field to
that value:</p>
<div class="codehilite"><pre class="insert-before"><span></span>    <span class="n">endScope</span><span class="o">();</span>
</pre><div class="source-file"><em>lox/Resolver.java</em><br>
in <em>resolveFunction</em>()</div>
<pre class="insert"><span></span>    <span class="n">currentFunction</span> <span class="o">=</span> <span class="n">enclosingFunction</span><span class="o">;</span>
</pre><pre class="insert-after"><span></span>  <span class="o">}</span>
</pre></div>

<p>Now that we can always tell whether or not we&rsquo;re inside a function declaration,
we check that when resolving a return statement:</p>
<div class="codehilite"><pre class="insert-before"><span></span>  <span class="kd">public</span> <span class="n">Void</span> <span class="nf">visitReturnStmt</span><span class="o">(</span><span class="n">Stmt</span><span class="o">.</span><span class="na">Return</span> <span class="n">stmt</span><span class="o">)</span> <span class="o">{</span>
</pre><div class="source-file"><em>lox/Resolver.java</em><br>
in <em>visitReturnStmt</em>()</div>
<pre class="insert"><span></span>    <span class="k">if</span> <span class="o">(</span><span class="n">currentFunction</span> <span class="o">==</span> <span class="n">FunctionType</span><span class="o">.</span><span class="na">NONE</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">Lox</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="n">stmt</span><span class="o">.</span><span class="na">keyword</span><span class="o">,</span> <span class="s">&quot;Cannot return from top-level code.&quot;</span><span class="o">);</span>
    <span class="o">}</span>
<br></pre><pre class="insert-after"><span></span>    <span class="k">if</span> <span class="o">(</span><span class="n">stmt</span><span class="o">.</span><span class="na">value</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</pre></div>

<p>Neat, right?</p>
<p>There&rsquo;s one more piece. Back in the main Lox class that stitches everything
together, we are careful to not run the interpreter if any parse errors are
encounter. That check runs <em>before</em> the resolver so that we don&rsquo;t try to resolve
syntactically invalid code.</p>
<p>But we also need to skip the interpreter if there are resolution errors, so we
add <em>another</em> check:</p>
<div class="codehilite"><pre class="insert-before"><span></span>    <span class="n">resolver</span><span class="o">.</span><span class="na">resolve</span><span class="o">(</span><span class="n">statements</span><span class="o">);</span>
</pre><div class="source-file"><em>lox/Lox.java</em><br>
in <em>run</em>()</div>
<pre class="insert"><br><span></span>    <span class="c1">// Stop if there was a resolution error.</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">hadError</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>
</pre><pre class="insert-after"><br><span></span>    <span class="n">interpreter</span><span class="o">.</span><span class="na">interpret</span><span class="o">(</span><span class="n">statements</span><span class="o">);</span>
</pre></div>

<ul>
<li>also &ldquo;syntax&rdquo; or &ldquo;compile&rdquo; error</li>
<li>check between both parser and resolver</li>
<li>
<p>don&rsquo;t want to resolve code with parse errors&#8202;&mdash;&#8202;too many cascades</p>
</li>
<li>
<p>imagine doing other analysis</p>
</li>
<li>track which fns don&rsquo;t access outer vars and use cheaper rep</li>
</ul>
<hr />
<ul>
<li>
<p>[once have closures, even more interesting question about whether redefining
  existing var or defining new one]</p>
<p>var a = &ldquo;before&rdquo;;
fun f() {
  print a;
}
var a = &ldquo;after&rdquo;;
f(); // ???</p>
</li>
<li>
<p>equivalent prog in scheme prints &ldquo;after&rdquo;</p>
</li>
<li>are redefining existing var</li>
<li>var decl is treated exactly like assignment (at top level) if var exists</li>
<li>in ml, prints &ldquo;before&rdquo;</li>
<li>second &ldquo;var a&rdquo; introduces new a that is only visible to later code</li>
<li>existing code, like f() still sees orig</li>
</ul>
<p>q:</p>
<ul>
<li>how do other languages handle &ldquo;var a = a&rdquo;</li>
<li>runtime error in python</li>
</ul>

<footer>
<a href="classes.html" class="next">
  Next Chapter: &ldquo;Classes&rdquo; &rarr;
</a>
Hand-crafted by Robert Nystrom&ensp;&mdash;&ensp;<a href="https://github.com/munificent/craftinginterpreters/blob/master/LICENSE" target="_blank">&copy; 2015&hairsp;&ndash;&hairsp;2017</a>
</footer>
</article>

</div>
</body>
</html>